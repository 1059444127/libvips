<STRUCT>
<NAME>SinkBase</NAME>
typedef struct _SinkBase {
	VipsImage *im;

	/* The position we're at in buf.
	 */
	int x;
	int y;

	/* The tilesize we've picked.
	 */
	int tile_width;
	int tile_height;
	int nlines;

} SinkBase;
</STRUCT>
<FUNCTION>
<NAME>vips_sink_base_init</NAME>
<RETURNS>void  </RETURNS>
 SinkBase *sink_base, VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_sink_thread_state_new</NAME>
<RETURNS>VipsThreadState  *</RETURNS>
 VipsImage *im, void *a 
</FUNCTION>
<FUNCTION>
<NAME>vips_sink_base_allocate</NAME>
<RETURNS>int  </RETURNS>
 VipsThreadState *state, void *a, gboolean *stop 
</FUNCTION>
<FUNCTION>
<NAME>vips_sink_base_progress</NAME>
<RETURNS>int  </RETURNS>
 void *a 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_UNARY</NAME>
#define VIPS_TYPE_UNARY (vips_unary_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_UNARY</NAME>
#define VIPS_UNARY( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), VIPS_TYPE_UNARY, VipsUnary ))
</MACRO>
<MACRO>
<NAME>VIPS_UNARY_CLASS</NAME>
#define VIPS_UNARY_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), VIPS_TYPE_UNARY, VipsUnaryClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_UNARY</NAME>
#define VIPS_IS_UNARY( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_UNARY ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_UNARY_CLASS</NAME>
#define VIPS_IS_UNARY_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_UNARY ))
</MACRO>
<MACRO>
<NAME>VIPS_UNARY_GET_CLASS</NAME>
#define VIPS_UNARY_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), VIPS_TYPE_UNARY, VipsUnaryClass ))
</MACRO>
<STRUCT>
<NAME>VipsUnary</NAME>
typedef struct _VipsUnary {
	VipsArithmetic parent_instance;

	VipsImage *in;

} VipsUnary;
</STRUCT>
<TYPEDEF>
<NAME>VipsUnaryClass</NAME>
typedef VipsArithmeticClass VipsUnaryClass;
</TYPEDEF>
<FUNCTION>
<NAME>vips_unary_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_BINARY</NAME>
#define VIPS_TYPE_BINARY (vips_binary_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_BINARY</NAME>
#define VIPS_BINARY( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), VIPS_TYPE_BINARY, VipsBinary ))
</MACRO>
<MACRO>
<NAME>VIPS_BINARY_CLASS</NAME>
#define VIPS_BINARY_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), VIPS_TYPE_BINARY, VipsBinaryClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_BINARY</NAME>
#define VIPS_IS_BINARY( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_BINARY ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_BINARY_CLASS</NAME>
#define VIPS_IS_BINARY_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_BINARY ))
</MACRO>
<MACRO>
<NAME>VIPS_BINARY_GET_CLASS</NAME>
#define VIPS_BINARY_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), VIPS_TYPE_BINARY, VipsBinaryClass ))
</MACRO>
<STRUCT>
<NAME>VipsBinary</NAME>
typedef struct _VipsBinary {
	VipsArithmetic parent_instance;

	/* Original left and right image args.
	 */
	VipsImage *left;
	VipsImage *right;

} VipsBinary;
</STRUCT>
<TYPEDEF>
<NAME>VipsBinaryClass</NAME>
typedef VipsArithmeticClass VipsBinaryClass;
</TYPEDEF>
<FUNCTION>
<NAME>vips_binary_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_UNARY_CONST</NAME>
#define VIPS_TYPE_UNARY_CONST (vips_unary_const_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_UNARY_CONST</NAME>
#define VIPS_UNARY_CONST( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
		VIPS_TYPE_UNARY_CONST, VipsUnaryConst ))
</MACRO>
<MACRO>
<NAME>VIPS_UNARY_CONST_CLASS</NAME>
#define VIPS_UNARY_CONST_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
		VIPS_TYPE_UNARY_CONST, VipsUnaryConstClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_UNARY_CONST</NAME>
#define VIPS_IS_UNARY_CONST( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_UNARY_CONST ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_UNARY_CONST_CLASS</NAME>
#define VIPS_IS_UNARY_CONST_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_UNARY_CONST ))
</MACRO>
<MACRO>
<NAME>VIPS_UNARY_CONST_GET_CLASS</NAME>
#define VIPS_UNARY_CONST_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
		VIPS_TYPE_UNARY_CONST, VipsUnaryConstClass ))
</MACRO>
<STRUCT>
<NAME>VipsUnaryConst</NAME>
typedef struct _VipsUnaryConst {
	VipsUnary parent_instance;

	/* Our constants.
	 */
	VipsArea *c;

	/* The format the constant should be cast to. Subclasses set this
	 * ready for unaryconst's build method.
	 */
	VipsBandFmt const_format;

	/* Our constant expanded to match arith->ready in size and
	 * const_format in type.
	 */
	int n;
	PEL *c_ready;

} VipsUnaryConst;
</STRUCT>
<STRUCT>
<NAME>VipsUnaryConstClass</NAME>
typedef struct _VipsUnaryConstClass {
	VipsUnaryClass parent_class;

} VipsUnaryConstClass;
</STRUCT>
<FUNCTION>
<NAME>vips_unary_const_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_STATISTIC</NAME>
#define VIPS_TYPE_STATISTIC (vips_statistic_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_STATISTIC</NAME>
#define VIPS_STATISTIC( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
		VIPS_TYPE_STATISTIC, VipsStatistic ))
</MACRO>
<MACRO>
<NAME>VIPS_STATISTIC_CLASS</NAME>
#define VIPS_STATISTIC_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
		VIPS_TYPE_STATISTIC, VipsStatisticClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_STATISTIC</NAME>
#define VIPS_IS_STATISTIC( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_STATISTIC ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_STATISTIC_CLASS</NAME>
#define VIPS_IS_STATISTIC_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_STATISTIC ))
</MACRO>
<MACRO>
<NAME>VIPS_STATISTIC_GET_CLASS</NAME>
#define VIPS_STATISTIC_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
		VIPS_TYPE_STATISTIC, VipsStatisticClass ))
</MACRO>
<USER_FUNCTION>
<NAME>VipsStatisticStartFn</NAME>
<RETURNS>void *</RETURNS>
 VipsStatistic *statistic 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>VipsStatisticScanFn</NAME>
<RETURNS>int </RETURNS>
 VipsStatistic *statistic, 
	void *seq, int x, int y, void *p, int n 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>VipsStatisticStopFn</NAME>
<RETURNS>int </RETURNS>
 VipsStatistic *statistic, void *seq 
</USER_FUNCTION>
<STRUCT>
<NAME>VipsStatistic</NAME>
struct _VipsStatistic {
	VipsOperation parent_instance;

	/* All have an input image.
	 */
	VipsImage *in;

	/* Set this to stop computation early.
	 */
	gboolean stop;

	/* Client data for the subclass.
	 */
	void *a; 
	void *b;
};
</STRUCT>
<STRUCT>
<NAME>VipsStatisticClass</NAME>
struct _VipsStatisticClass {
	VipsOperationClass parent_class;

	/* Start/scan/stop, for vips_sink.
	 */
	VipsStatisticStartFn start; 
	VipsStatisticScanFn scan; 
	VipsStatisticStopFn stop;
};
</STRUCT>
<FUNCTION>
<NAME>vips_statistic_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_ARITHMETIC</NAME>
#define VIPS_TYPE_ARITHMETIC (vips_arithmetic_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_ARITHMETIC</NAME>
#define VIPS_ARITHMETIC( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
		VIPS_TYPE_ARITHMETIC, VipsArithmetic ))
</MACRO>
<MACRO>
<NAME>VIPS_ARITHMETIC_CLASS</NAME>
#define VIPS_ARITHMETIC_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
		VIPS_TYPE_ARITHMETIC, VipsArithmeticClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_ARITHMETIC</NAME>
#define VIPS_IS_ARITHMETIC( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_ARITHMETIC ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_ARITHMETIC_CLASS</NAME>
#define VIPS_IS_ARITHMETIC_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_ARITHMETIC ))
</MACRO>
<MACRO>
<NAME>VIPS_ARITHMETIC_GET_CLASS</NAME>
#define VIPS_ARITHMETIC_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
		VIPS_TYPE_ARITHMETIC, VipsArithmeticClass ))
</MACRO>
<USER_FUNCTION>
<NAME>VipsArithmeticProcessFn</NAME>
<RETURNS>void </RETURNS>
 struct _VipsArithmetic *arithmetic, 
	PEL *out, PEL **in, int width 
</USER_FUNCTION>
<STRUCT>
<NAME>VipsArithmetic</NAME>
typedef struct _VipsArithmetic {
	VipsOperation parent_instance;

	/* All have an output image.
	 */
	VipsImage *out;

	/* Array of input arguments, set these from a subclass.
	 */
	VipsImage **in;
	int n;

	/* The minimum number of output bands. For example, VipsLinear with a
	 * three element constant must make at least a three-band output.
	 */
	int base_bands;

	/* The input images, ready for the operation.
	 */
	VipsImage **ready;
} VipsArithmetic;
</STRUCT>
<STRUCT>
<NAME>VipsArithmeticClass</NAME>
typedef struct _VipsArithmeticClass {
	VipsOperationClass parent_class;

	/* For each input format, what output format. Used for arithmetic
	 * too, since we cast inputs to match.
	 */
	const VipsBandFormat *format_table;

	/* A vector program for each input type.
	 */
	VipsVector *vectors[VIPS_FORMAT_LAST];

	/* ... and if we've set a program for this format.
	 */
	gboolean vector_program[VIPS_FORMAT_LAST];

	/* The buffer processor.
	 */
	VipsArithmeticProcessFn process_line;
} VipsArithmeticClass;
</STRUCT>
<FUNCTION>
<NAME>vips_arithmetic_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_arithmetic_set_format_table</NAME>
<RETURNS>void  </RETURNS>
 VipsArithmeticClass *klass, const VipsBandFormat *format_table 
</FUNCTION>
<FUNCTION>
<NAME>vips_arithmetic_get_vector</NAME>
<RETURNS>VipsVector  *</RETURNS>
 VipsArithmeticClass *klass, VipsBandFormat fmt 
</FUNCTION>
<FUNCTION>
<NAME>vips_arithmetic_compile</NAME>
<RETURNS>void  </RETURNS>
 VipsArithmeticClass *klass 
</FUNCTION>
<FUNCTION>
<NAME>vips_arithmetic_get_program</NAME>
<RETURNS>VipsVector  *</RETURNS>
 VipsArithmeticClass *klass, VipsBandFormat fmt 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_CONVERSION</NAME>
#define VIPS_TYPE_CONVERSION (vips_conversion_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_CONVERSION</NAME>
#define VIPS_CONVERSION( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
		VIPS_TYPE_CONVERSION, VipsConversion ))
</MACRO>
<MACRO>
<NAME>VIPS_CONVERSION_CLASS</NAME>
#define VIPS_CONVERSION_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
		VIPS_TYPE_CONVERSION, VipsConversionClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_CONVERSION</NAME>
#define VIPS_IS_CONVERSION( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_CONVERSION ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_CONVERSION_CLASS</NAME>
#define VIPS_IS_CONVERSION_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_CONVERSION ))
</MACRO>
<MACRO>
<NAME>VIPS_CONVERSION_GET_CLASS</NAME>
#define VIPS_CONVERSION_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
		VIPS_TYPE_CONVERSION, VipsConversionClass ))
</MACRO>
<STRUCT>
<NAME>VipsConversion</NAME>
typedef struct _VipsConversion {
	VipsOperation parent_instance;

	/* All have an output image.
	 */
	VipsImage *out;

} VipsConversion;
</STRUCT>
<STRUCT>
<NAME>VipsConversionClass</NAME>
typedef struct _VipsConversionClass {
	VipsOperationClass parent_class;

} VipsConversionClass;
</STRUCT>
<FUNCTION>
<NAME>vips_conversion_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<STRUCT>
<NAME>Draw</NAME>
typedef struct _Draw {
	/* Parameters.
	 */
	IMAGE *im;		/* Draw here */
	PEL *ink;		/* Copy of ink param */

	/* Derived stuff.
	 */
	size_t lsize;
	size_t psize;

	/* If the object to draw is entirely within the image, we have a 
	 * faster noclip path.
	 */
	gboolean noclip;
} Draw;
</STRUCT>
<MACRO>
<NAME>DRAW</NAME>
#define DRAW(X) ((Draw *)(X))
</MACRO>
<FUNCTION>
<NAME>im__draw_pel</NAME>
<RETURNS>void </RETURNS>
 Draw *draw, PEL *q 
</FUNCTION>
<FUNCTION>
<NAME>im__draw_pel_clip</NAME>
<RETURNS>void </RETURNS>
 Draw *draw, int x, int y 
</FUNCTION>
<FUNCTION>
<NAME>im__draw_painted</NAME>
<RETURNS>gboolean </RETURNS>
 Draw *draw, PEL *p 
</FUNCTION>
<FUNCTION>
<NAME>im__draw_scanline</NAME>
<RETURNS>void  </RETURNS>
 Draw *draw, int y, int x1, int x2 
</FUNCTION>
<FUNCTION>
<NAME>im__draw_free</NAME>
<RETURNS>void  </RETURNS>
 Draw *draw 
</FUNCTION>
<FUNCTION>
<NAME>im__draw_init</NAME>
<RETURNS>Draw  *</RETURNS>
 Draw *draw, IMAGE *im, PEL *ink 
</FUNCTION>
<USER_FUNCTION>
<NAME>VipsCallbackFn</NAME>
<RETURNS>int </RETURNS>
 void *a, void *b 
</USER_FUNCTION>
<STRUCT>
<NAME>VipsArea</NAME>
typedef struct _VipsArea {
	void *data;
	size_t length;		/* 0 if not known */

	/* If this area represents an array, the number of elements in the
	 * array. Equal to length / sizeof(element).
	 */
	int n;

	/*< private >*/

	/* Reference count.
	 */
	int count;

	/* Things like ICC profiles need their own free functions.
	 */
	VipsCallbackFn free_fn;

	/* If we are holding an array (for exmaple, an array of double), the
	 * GType of the elements and their size. 0 for not known.
	 *
	 * n is always length / sizeof_type, we keep it as a member for
	 * convenience.
	 */
	GType type;
	size_t sizeof_type;
} VipsArea;
</STRUCT>
<FUNCTION>
<NAME>vips_area_copy</NAME>
<RETURNS>VipsArea  *</RETURNS>
 VipsArea *area 
</FUNCTION>
<FUNCTION>
<NAME>vips_area_unref</NAME>
<RETURNS>void  </RETURNS>
 VipsArea *area 
</FUNCTION>
<FUNCTION>
<NAME>vips_area_new</NAME>
<RETURNS>VipsArea  *</RETURNS>
 VipsCallbackFn free_fn, void *data 
</FUNCTION>
<FUNCTION>
<NAME>vips_area_new_blob</NAME>
<RETURNS>VipsArea  *</RETURNS>
 VipsCallbackFn free_fn, void *blob, size_t blob_length 
</FUNCTION>
<FUNCTION>
<NAME>vips_area_new_array</NAME>
<RETURNS>VipsArea  *</RETURNS>
 GType type, size_t sizeof_type, int n 
</FUNCTION>
<FUNCTION>
<NAME>vips_area_new_array_object</NAME>
<RETURNS>VipsArea  *</RETURNS>
 int n 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_AREA</NAME>
#define VIPS_TYPE_AREA (vips_area_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_value_set_area</NAME>
<RETURNS>int  </RETURNS>
 GValue *value, VipsCallbackFn free_fn, void *data 
</FUNCTION>
<FUNCTION>
<NAME>vips_value_get_area</NAME>
<RETURNS>void  *</RETURNS>
 const GValue *value, size_t *length 
</FUNCTION>
<FUNCTION>
<NAME>vips_area_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_SAVE_STRING</NAME>
#define VIPS_TYPE_SAVE_STRING (vips_save_string_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_value_get_save_string</NAME>
<RETURNS>const char  *</RETURNS>
 const GValue *value 
</FUNCTION>
<FUNCTION>
<NAME>vips_value_set_save_string</NAME>
<RETURNS>void  </RETURNS>
 GValue *value, const char *str 
</FUNCTION>
<FUNCTION>
<NAME>vips_value_set_save_stringf</NAME>
<RETURNS>void  </RETURNS>
 GValue *value, const char *fmt, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_save_string_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_REF_STRING</NAME>
#define VIPS_TYPE_REF_STRING (vips_ref_string_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_value_get_ref_string</NAME>
<RETURNS>const char  *</RETURNS>
 const GValue *value, size_t *length 
</FUNCTION>
<FUNCTION>
<NAME>vips_value_set_ref_string</NAME>
<RETURNS>int  </RETURNS>
 GValue *value, const char *str 
</FUNCTION>
<FUNCTION>
<NAME>vips_ref_string_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_BLOB</NAME>
#define VIPS_TYPE_BLOB (vips_blob_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_value_get_blob</NAME>
<RETURNS>void  *</RETURNS>
 const GValue *value, size_t *length 
</FUNCTION>
<FUNCTION>
<NAME>vips_value_set_blob</NAME>
<RETURNS>int  </RETURNS>
 GValue *value, VipsCallbackFn free_fn, void *data, size_t length 
</FUNCTION>
<FUNCTION>
<NAME>vips_blob_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_value_set_array</NAME>
<RETURNS>int  </RETURNS>
 GValue *value, GType type, size_t sizeof_type, int n 
</FUNCTION>
<FUNCTION>
<NAME>vips_value_get_array</NAME>
<RETURNS>void  *</RETURNS>
 const GValue *value, int *n, GType *type, size_t *sizeof_type 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_ARRAY_DOUBLE</NAME>
#define VIPS_TYPE_ARRAY_DOUBLE (vips_array_double_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_value_get_array_double</NAME>
<RETURNS>double  *</RETURNS>
 const GValue *value, int *n 
</FUNCTION>
<FUNCTION>
<NAME>vips_value_set_array_double</NAME>
<RETURNS>int  </RETURNS>
 GValue *value, const double *array, int n 
</FUNCTION>
<FUNCTION>
<NAME>vips_array_double_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_ARRAY_IMAGE</NAME>
#define VIPS_TYPE_ARRAY_IMAGE (vips_array_image_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_value_get_array_object</NAME>
<RETURNS>GObject  **</RETURNS>
 const GValue *value, int *n 
</FUNCTION>
<FUNCTION>
<NAME>vips_value_set_array_object</NAME>
<RETURNS>int  </RETURNS>
 GValue *value, int n 
</FUNCTION>
<FUNCTION>
<NAME>vips_array_image_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips__meta_init_types</NAME>
<RETURNS>void  </RETURNS>
 void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_OPERATION</NAME>
#define VIPS_TYPE_OPERATION (vips_operation_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_OPERATION</NAME>
#define VIPS_OPERATION( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
		VIPS_TYPE_OPERATION, VipsOperation ))
</MACRO>
<MACRO>
<NAME>VIPS_OPERATION_CLASS</NAME>
#define VIPS_OPERATION_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
		VIPS_TYPE_OPERATION, VipsOperationClass ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_OPERATION</NAME>
#define VIPS_IS_OPERATION( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_OPERATION ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_OPERATION_CLASS</NAME>
#define VIPS_IS_OPERATION_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_OPERATION ))
</MACRO>
<MACRO>
<NAME>VIPS_OPERATION_GET_CLASS</NAME>
#define VIPS_OPERATION_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
		VIPS_TYPE_OPERATION, VipsOperationClass ))
</MACRO>
<USER_FUNCTION>
<NAME>VipsOperationBuildFn</NAME>
<RETURNS>gboolean </RETURNS>
 VipsObject * 
</USER_FUNCTION>
<STRUCT>
<NAME>VipsOperation</NAME>
typedef struct _VipsOperation {
	VipsObject parent_instance;

	/* When we added this oepration to cache .. used to find LRU for
	 * flush.
	 */
	int time;

	/* Keep the hash here.
	 */
	guint hash;
	gboolean found_hash;

} VipsOperation;
</STRUCT>
<STRUCT>
<NAME>VipsOperationClass</NAME>
typedef struct _VipsOperationClass {
	VipsObjectClass parent_class;

} VipsOperationClass;
</STRUCT>
<FUNCTION>
<NAME>vips_operation_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_operation_call_valist</NAME>
<RETURNS>int  </RETURNS>
 VipsOperation *operation, va_list ap 
</FUNCTION>
<FUNCTION>
<NAME>vips_operation_new</NAME>
<RETURNS>VipsOperation  *</RETURNS>
 const char *name 
</FUNCTION>
<FUNCTION>
<NAME>vips_call</NAME>
<RETURNS>int  </RETURNS>
 const char *operation_name, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_call_split</NAME>
<RETURNS>int  </RETURNS>
 const char *operation_name, va_list optional, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_call_options</NAME>
<RETURNS>void  </RETURNS>
 GOptionGroup *group, VipsOperation *operation 
</FUNCTION>
<FUNCTION>
<NAME>vips_call_argv</NAME>
<RETURNS>int  </RETURNS>
 VipsOperation *operation, int argc, char **argv 
</FUNCTION>
<FUNCTION>
<NAME>vips_cache_drop_all</NAME>
<RETURNS>void  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_cache_operation_build</NAME>
<RETURNS>int  </RETURNS>
 VipsOperation **operation 
</FUNCTION>
<FUNCTION>
<NAME>vips_cache_set_max</NAME>
<RETURNS>void  </RETURNS>
 int max 
</FUNCTION>
<FUNCTION>
<NAME>vips_cache_set_max_mem</NAME>
<RETURNS>void  </RETURNS>
 int max_mem 
</FUNCTION>
<FUNCTION>
<NAME>vips_cache_get_max</NAME>
<RETURNS>int  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_cache_get_size</NAME>
<RETURNS>int  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_cache_get_max_mem</NAME>
<RETURNS>size_t  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_cache_get_max_files</NAME>
<RETURNS>int  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_cache_set_max_files</NAME>
<RETURNS>void  </RETURNS>
 int max_files 
</FUNCTION>
<MACRO>
<NAME>VIPS_MAGIC_INTEL</NAME>
#define VIPS_MAGIC_INTEL (0xb6a6f208U)
</MACRO>
<MACRO>
<NAME>VIPS_MAGIC_SPARC</NAME>
#define VIPS_MAGIC_SPARC (0x08f2a6b6U)
</MACRO>
<ENUM>
<NAME>VipsDemandStyle</NAME>
typedef enum {
	VIPS_DEMAND_STYLE_SMALLTILE,	
	VIPS_DEMAND_STYLE_FATSTRIP,
	VIPS_DEMAND_STYLE_THINSTRIP,
	VIPS_DEMAND_STYLE_ANY			
} VipsDemandStyle;
</ENUM>
<ENUM>
<NAME>VipsImageType</NAME>
typedef enum {
	VIPS_IMAGE_NONE,		/* no type set */
	VIPS_IMAGE_SETBUF,		/* malloced memory array */
	VIPS_IMAGE_SETBUF_FOREIGN,	/* memory array, don't free on close */
	VIPS_IMAGE_OPENIN,		/* input from fd with a window */
	VIPS_IMAGE_MMAPIN,		/* memory mapped input file */
	VIPS_IMAGE_MMAPINRW,		/* memory mapped read/write file */
	VIPS_IMAGE_OPENOUT,		/* output to fd */
	VIPS_IMAGE_PARTIAL		/* partial image */
} VipsImageType;
</ENUM>
<ENUM>
<NAME>VipsInterpretation</NAME>
typedef enum {
	VIPS_INTERPRETATION_MULTIBAND = 0,
	VIPS_INTERPRETATION_B_W = 1,
	VIPS_INTERPRETATION_HISTOGRAM = 10,
	VIPS_INTERPRETATION_FOURIER = 24,
	VIPS_INTERPRETATION_XYZ = 12,
	VIPS_INTERPRETATION_LAB = 13,
	VIPS_INTERPRETATION_CMYK = 15,
	VIPS_INTERPRETATION_LABQ = 16,
	VIPS_INTERPRETATION_RGB = 17,
	VIPS_INTERPRETATION_UCS = 18,
	VIPS_INTERPRETATION_LCH = 19,
	VIPS_INTERPRETATION_LABS = 21,
	VIPS_INTERPRETATION_sRGB = 22,
	VIPS_INTERPRETATION_YXY = 23,
	VIPS_INTERPRETATION_RGB16 = 25,
	VIPS_INTERPRETATION_GREY16 = 26,
	VIPS_INTERPRETATION_ARRAY = 27
} VipsInterpretation;
</ENUM>
<ENUM>
<NAME>VipsBandFormat</NAME>
typedef enum {
	VIPS_FORMAT_NOTSET = -1,
	VIPS_FORMAT_UCHAR = 0,
	VIPS_FORMAT_CHAR = 1,
	VIPS_FORMAT_USHORT = 2,
	VIPS_FORMAT_SHORT = 3,
	VIPS_FORMAT_UINT = 4,
	VIPS_FORMAT_INT = 5,
	VIPS_FORMAT_FLOAT = 6,
	VIPS_FORMAT_COMPLEX = 7,
	VIPS_FORMAT_DOUBLE = 8,
	VIPS_FORMAT_DPCOMPLEX = 9,
	VIPS_FORMAT_LAST = 10
} VipsBandFormat;
</ENUM>
<ENUM>
<NAME>VipsCoding</NAME>
typedef enum {
	VIPS_CODING_NONE = 0,
	VIPS_CODING_LABQ = 2,
	VIPS_CODING_RAD = 6
} VipsCoding;
</ENUM>
<STRUCT>
<NAME>VipsProgress</NAME>
typedef struct {
	/*< private >*/
	struct _VipsImage *im;	/* Image we are part of */

	/*< public >*/
	int run;		/* Time we have been running */
	int eta;		/* Estimated seconds of computation left */
	gint64 tpels;		/* Number of pels we expect to calculate */
	gint64 npels;		/* Number of pels calculated so far */
	int percent;		/* Percent complete */
	GTimer *start;		/* Start time */
} VipsProgress;
</STRUCT>
<MACRO>
<NAME>VIPS_TYPE_IMAGE</NAME>
#define VIPS_TYPE_IMAGE (vips_image_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_IMAGE</NAME>
#define VIPS_IMAGE( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
	VIPS_TYPE_IMAGE, VipsImage ))
</MACRO>
<MACRO>
<NAME>VIPS_IMAGE_CLASS</NAME>
#define VIPS_IMAGE_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
	VIPS_TYPE_IMAGE, VipsImageClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_IMAGE</NAME>
#define VIPS_IS_IMAGE( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_IMAGE ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_IMAGE_CLASS</NAME>
#define VIPS_IS_IMAGE_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_IMAGE ))
</MACRO>
<MACRO>
<NAME>VIPS_IMAGE_GET_CLASS</NAME>
#define VIPS_IMAGE_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
	VIPS_TYPE_IMAGE, VipsImageClass ))
</MACRO>
<STRUCT>
<NAME>VipsImage</NAME>
typedef struct _VipsImage {
	VipsObject parent_object;

	/*< private >*/

	/* We have to keep these names for compatibility with the old API.
	 * Don't use them though, use vips_image_get_width() and friends.
	 */

	int Xsize;		/* image width, in pixels */
	int Ysize;		/* image height, in pixels */
	int Bands;		/* number of image bands */

	VipsBandFormat BandFmt;	/* pixel format */
	VipsCoding Coding;	/* pixel coding */
	VipsInterpretation Type;/* pixel interpretation */
	float Xres;		/* horizontal pixels per millimetre */
	float Yres;		/* vertical pixels per millimetre */

	int Xoffset;		/* image origin hint */
	int Yoffset;		/* image origin hint */

	/* No longer used, the names are here for compat with very, very old 
	 * code.
	 */
	int Length;
	short Compression;
	short Level;
	int Bbits;		/* was number of bits in this format */

	/* Old code expects to see this member, newer code has a param on
	 * eval().
	 */
	VipsProgress *time;

	/* Derived fields that some code can fiddle with. New code should use
	 * vips_image_get_history() and friends.
	 */
	char *Hist;		/* don't use, see vips_image_get_history() */
	char *filename;		/* pointer to copy of filename */
	char *data;		/* start of image data for WIO */
	int kill;		/* set to non-zero to block eval */

	/* Everything below this private and only used internally by
	 * VipsImage.
	 */

	char *mode;		/* mode string passed to _new() */
	VipsImageType dtype;	/* descriptor type */
	int fd;         	/* file descriptor */
	char *baseaddr;     	/* pointer to the start of an mmap file */
	size_t length;		/* size of mmap area */
	guint32 magic;		/* magic from header, endian-ness of image */

	/* Partial image stuff. All these fields are initialised 
	 * to NULL and ignored unless set by vips_image_generate() etc.
	 */
	void *(*start_fn)();	/* user-supplied start function */
	int (*generate_fn)();	/* user-supplied generate function */
	int (*stop_fn)();	/* user-supplied stop function */
	void *client1;		/* user arguments */
	void *client2;
	GMutex *sslock;		/* start-stop lock */
	GSList *regions; 	/* list of regions current for this image */
	VipsDemandStyle dhint;	/* demand style hint */

	/* Extra user-defined fields ... see vips_image_get() etc.
	 */
	GHashTable *meta;	/* GhashTable of GValue */
	GSList *meta_traverse;	/* traverse order for Meta */

	/* Part of mmap() read ... the sizeof() the header we skip from the
	 * file start. Usually VIPS_SIZEOF_HEADER, but can be something else
	 * for binary file read.
	 */
	int sizeof_header;

	/* If this is a large disc image, don't map the whole thing, instead
	 * have a set of windows shared between the regions active on the
	 * image. List of VipsWindow.
	 */
	GSList *windows;

	/* Upstream/downstream relationships, built from args to 
	 * vips_demand_hint().
	 *
	 * We use these to invalidate downstream pixel buffers.
	 * Use 'serial' to spot circular dependencies.
	 *
	 * See also hint_set below.
	 */
	GSList *upstream;
	GSList *downstream;
	int serial;

	/* Keep a list of recounted GValue strings so we can share hist
	 * efficiently.
	 */
	GSList *history_list;

	/* The VipsImage (if any) we should signal eval progress on.
	 */
	struct _VipsImage *progress_signal;

	/* Record the file length here. We use this to stop ourselves mapping
	 * things beyond the end of the file in the case that the file has
	 * been truncated.
	 *
	 * gint64 so that we can guarantee to work even on systems with
	 * strange ideas about large files.
	 */
	gint64 file_length;

	/* Set this when vips_demand_hint_array() is called, and check in any
	 * operation that will demand pixels from the image.
	 *
	 * We use vips_demand_hint_array() to build the tree of
	 * upstream/downstream relationships, so it's a mandatory thing.
	 */
	gboolean hint_set;

	/* Delete-on-close is hard to do with signals and callbacks since we
	 * really need to do this in finalize after the fd has been closed,
	 * but you can't emit signals then.
	 *
	 * Also keep a private copy of the filename string to be deleted,
	 * since image->filename will be freed in _dispose().
	 */
	gboolean delete_on_close;
	char *delete_on_close_filename;

} VipsImage;
</STRUCT>
<STRUCT>
<NAME>VipsImageClass</NAME>
typedef struct _VipsImageClass {
	VipsObjectClass parent_class;

	/* Signals we emit.
	 */

	/* Evaluation is starting.
	 */
	void (*preeval)( VipsImage *image, VipsProgress *progress );

	/* Evaluation progress.
	 */
	void (*eval)( VipsImage *image, VipsProgress *progress );

	/* Evaluation is ending.
	 */
	void (*posteval)( VipsImage *image, VipsProgress *progress );

	/* An image has been written to. 
	 * Used by eg. vips_image_new_mode("x.jpg", "w") to do the 
	 * final write to jpeg.
	 * Set *result to non-zero to indicate an error on write.
	 */
	void (*written)( VipsImage *image, int *result );

	/* An image has been modified in some way and all caches 
	 * need dropping. 
	 */
	void (*invalidate)( VipsImage *image );

} VipsImageClass;
</STRUCT>
<FUNCTION>
<NAME>vips_image_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<MACRO>
<NAME>VIPS_IMAGE_SIZEOF_ELEMENT</NAME>
#define VIPS_IMAGE_SIZEOF_ELEMENT( I ) \
	(vips__image_sizeof_bandformat[(I)->BandFmt])
</MACRO>
<MACRO>
<NAME>VIPS_IMAGE_SIZEOF_PEL</NAME>
#define VIPS_IMAGE_SIZEOF_PEL( I ) \
	(VIPS_IMAGE_SIZEOF_ELEMENT( I ) * (I)->Bands)
</MACRO>
<MACRO>
<NAME>VIPS_IMAGE_SIZEOF_LINE</NAME>
#define VIPS_IMAGE_SIZEOF_LINE( I ) \
	(VIPS_IMAGE_SIZEOF_PEL( I ) * (I)->Xsize)
</MACRO>
<MACRO>
<NAME>VIPS_IMAGE_SIZEOF_IMAGE</NAME>
#define VIPS_IMAGE_SIZEOF_IMAGE( I ) \
	(VIPS_IMAGE_SIZEOF_LINE( I ) * (I)->Ysize)
</MACRO>
<MACRO>
<NAME>VIPS_IMAGE_N_ELEMENTS</NAME>
#define VIPS_IMAGE_N_ELEMENTS( I ) \
	((I)->Bands * (I)->Xsize)
</MACRO>
<MACRO>
<NAME>VIPS_IMAGE_ADDR</NAME>
#define VIPS_IMAGE_ADDR( I, X, Y ) \
	( ((X) >= 0 && (X) < (I)->Xsize && \
	   (Y) >= 0 && (Y) < (I)->Ysize) ? \
	     ((I)->data + \
	       (Y) * VIPS_IMAGE_SIZEOF_LINE( I ) + \
	       (X) * VIPS_IMAGE_SIZEOF_PEL( I )) : \
	     (fprintf( stderr, \
		"VIPS_IMAGE_ADDR: point out of bounds, " \
		"file \"%s\", line %d\n" \
		"(point x=%d, y=%d\n" \
		" should have been within VipsRect left=%d, top=%d, " \
		"width=%d, height=%d)\n", \
		__FILE__, __LINE__, \
		(X), (Y), \
		0, 0, \
		(I)->Xsize, \
		(I)->Ysize ), abort(), (char *) NULL) \
	)
</MACRO>
<FUNCTION>
<NAME>vips_image_written</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_invalidate_all</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_preeval</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_eval</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, int w, int h 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_posteval</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_set_progress</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, gboolean progress 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_kill</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_set_kill</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, gboolean kill 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_new</NAME>
<RETURNS>VipsImage  *</RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_new_mode</NAME>
<RETURNS>VipsImage  *</RETURNS>
 const char *filename, const char *mode 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_new_from_file</NAME>
<RETURNS>VipsImage  *</RETURNS>
 const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_new_from_file_raw</NAME>
<RETURNS>VipsImage  *</RETURNS>
 const char *filename, int xsize, int ysize, int bands, int offset 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_new_from_memory</NAME>
<RETURNS>VipsImage  *</RETURNS>
 void *buffer, int xsize, int ysize, int bands, VipsBandFormat bandfmt 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_new_array</NAME>
<RETURNS>VipsImage  *</RETURNS>
 int xsize, int ysize 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_set_delete_on_close</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, gboolean delete_on_close 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_new_disc_temp</NAME>
<RETURNS>VipsImage  *</RETURNS>
 const char *format 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_write</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_write_to_file</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_isMSBfirst</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_isfile</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_ispartial</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_write_line</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, int ypos, PEL *linebuffer 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_wio_input</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_wio_output</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_inplace</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_pio_input</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_pio_output</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_band_format_isint</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBandFormat format 
</FUNCTION>
<FUNCTION>
<NAME>vips_band_format_isuint</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBandFormat format 
</FUNCTION>
<FUNCTION>
<NAME>vips_band_format_isfloat</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBandFormat format 
</FUNCTION>
<FUNCTION>
<NAME>vips_band_format_iscomplex</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBandFormat format 
</FUNCTION>
<FUNCTION>
<NAME>im_lrmerge</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *ref, VipsImage *sec, VipsImage *out, int dx, int dy, int mwidth 
</FUNCTION>
<FUNCTION>
<NAME>im_tbmerge</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *ref, VipsImage *sec, VipsImage *out, int dx, int dy, int mwidth 
</FUNCTION>
<FUNCTION>
<NAME>im_lrmerge1</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *ref, VipsImage *sec, VipsImage *out, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int mwidth 
</FUNCTION>
<FUNCTION>
<NAME>im_tbmerge1</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *ref, VipsImage *sec, VipsImage *out, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int mwidth 
</FUNCTION>
<FUNCTION>
<NAME>im_lrmosaic</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *ref, VipsImage *sec, VipsImage *out, int bandno, int xref, int yref, int xsec, int ysec, int hwindowsize, int hsearchsize, int balancetype, int mwidth 
</FUNCTION>
<FUNCTION>
<NAME>im_tbmosaic</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *ref, VipsImage *sec, VipsImage *out, int bandno, int xref, int yref, int xsec, int ysec, int hwindowsize, int hsearchsize, int balancetype, int mwidth 
</FUNCTION>
<FUNCTION>
<NAME>im_lrmosaic1</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *ref, VipsImage *sec, VipsImage *out, int bandno, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int hwindowsize, int hsearchsize, int balancetype, int mwidth 
</FUNCTION>
<FUNCTION>
<NAME>im_tbmosaic1</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *ref, VipsImage *sec, VipsImage *out, int bandno, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int hwindowsize, int hsearchsize, int balancetype, int mwidth 
</FUNCTION>
<FUNCTION>
<NAME>im_global_balance</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double gamma 
</FUNCTION>
<FUNCTION>
<NAME>im_global_balancef</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double gamma 
</FUNCTION>
<FUNCTION>
<NAME>im_correl</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *ref, VipsImage *sec, int xref, int yref, int xsec, int ysec, int hwindowsize, int hsearchsize, double *correlation, int *x, int *y 
</FUNCTION>
<FUNCTION>
<NAME>im_remosaic</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, const char *old_str, const char *new_str 
</FUNCTION>
<FUNCTION>
<NAME>im_align_bands</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_maxpos_subpel</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, double *x, double *y 
</FUNCTION>
<ENUM>
<NAME>VipsMaskType</NAME>
typedef enum {
        VIPS_MASK_IDEAL_HIGHPASS = 0,
        VIPS_MASK_IDEAL_LOWPASS = 1,
        VIPS_MASK_BUTTERWORTH_HIGHPASS = 2,
        VIPS_MASK_BUTTERWORTH_LOWPASS = 3,
        VIPS_MASK_GAUSS_HIGHPASS = 4,
        VIPS_MASK_GAUSS_LOWPASS = 5,

        VIPS_MASK_IDEAL_RINGPASS = 6,
        VIPS_MASK_IDEAL_RINGREJECT = 7,
        VIPS_MASK_BUTTERWORTH_RINGPASS = 8,
        VIPS_MASK_BUTTERWORTH_RINGREJECT = 9,
        VIPS_MASK_GAUSS_RINGPASS = 10,
        VIPS_MASK_GAUSS_RINGREJECT = 11,

        VIPS_MASK_IDEAL_BANDPASS = 12,
        VIPS_MASK_IDEAL_BANDREJECT = 13,
        VIPS_MASK_BUTTERWORTH_BANDPASS = 14,
        VIPS_MASK_BUTTERWORTH_BANDREJECT = 15,
        VIPS_MASK_GAUSS_BANDPASS = 16,
        VIPS_MASK_GAUSS_BANDREJECT = 17,

        VIPS_MASK_FRACTAL_FLT = 18
} VipsMaskType;
</ENUM>
<FUNCTION>
<NAME>im_fwfft</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_invfft</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_invfftr</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_freqflt</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *mask, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_disp_ps</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_rotquad</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_phasecor_fft</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_flt_image_freq</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, VipsMaskType flag, ... 
</FUNCTION>
<FUNCTION>
<NAME>im_create_fmask</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, int xsize, int ysize, VipsMaskType flag, ... 
</FUNCTION>
<FUNCTION>
<NAME>im_fractsurf</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, int size, double frd 
</FUNCTION>
<STRUCT>
<NAME>VipsBuf</NAME>
typedef struct {
	/* All fields are private.
	 */
	/* <private> */
	char *base;		/* String base */
	int mx;			/* Maximum length */
	int i;			/* Current write point */
	gboolean full;		/* String has filled, block writes */
	int lasti;		/* For read-recent */
	gboolean dynamic;	/* We own the string with malloc() */
} VipsBuf;
</STRUCT>
<MACRO>
<NAME>VIPS_BUF_STATIC</NAME>
#define VIPS_BUF_STATIC( TEXT ) \
	{ &TEXT[0], sizeof( TEXT ), 0, FALSE, 0, FALSE }
</MACRO>
<FUNCTION>
<NAME>vips_buf_rewind</NAME>
<RETURNS>void  </RETURNS>
 VipsBuf *buf 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_destroy</NAME>
<RETURNS>void  </RETURNS>
 VipsBuf *buf 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_init</NAME>
<RETURNS>void  </RETURNS>
 VipsBuf *buf 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_set_static</NAME>
<RETURNS>void  </RETURNS>
 VipsBuf *buf, char *base, int mx 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_set_dynamic</NAME>
<RETURNS>void  </RETURNS>
 VipsBuf *buf, int mx 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_init_static</NAME>
<RETURNS>void  </RETURNS>
 VipsBuf *buf, char *base, int mx 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_init_dynamic</NAME>
<RETURNS>void  </RETURNS>
 VipsBuf *buf, int mx 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_appendns</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, const char *str, int sz 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_appends</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, const char *str 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_appendf</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, const char *fmt, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_vappendf</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, const char *fmt, va_list ap 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_appendc</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, char ch 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_appendsc</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, gboolean quote, const char *str 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_appendgv</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, GValue *value 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_append_size</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, size_t n 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_removec</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, char ch 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_change</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, const char *o, const char *n 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_is_empty</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_is_full</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_all</NAME>
<RETURNS>const char  *</RETURNS>
 VipsBuf *buf 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_firstline</NAME>
<RETURNS>const char  *</RETURNS>
 VipsBuf *buf 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_appendg</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, double g 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_appendd</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsBuf *buf, int d 
</FUNCTION>
<FUNCTION>
<NAME>vips_buf_len</NAME>
<RETURNS>int  </RETURNS>
 VipsBuf *buf 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_THREAD_STATE</NAME>
#define VIPS_TYPE_THREAD_STATE (vips_thread_state_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_THREAD_STATE</NAME>
#define VIPS_THREAD_STATE( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
	VIPS_TYPE_THREAD_STATE, VipsThreadState ))
</MACRO>
<MACRO>
<NAME>VIPS_THREAD_STATE_CLASS</NAME>
#define VIPS_THREAD_STATE_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
	VIPS_TYPE_THREAD_STATE, VipsThreadStateClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_THREAD_STATE</NAME>
#define VIPS_IS_THREAD_STATE( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_THREAD_STATE ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_THREAD_STATE_CLASS</NAME>
#define VIPS_IS_THREAD_STATE_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_THREAD_STATE ))
</MACRO>
<MACRO>
<NAME>VIPS_THREAD_STATE_GET_CLASS</NAME>
#define VIPS_THREAD_STATE_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
	VIPS_TYPE_THREAD_STATE, VipsThreadStateClass ))
</MACRO>
<STRUCT>
<NAME>VipsThreadState</NAME>
typedef struct _VipsThreadState {
	VipsObject parent_object;

	/*< public >*/
	/* Image we run on.
	 */
	VipsImage *im;

	/* This region is created and destroyed by the threadpool for the
	 * use of the worker. 
	 */
	VipsRegion *reg;		

	/* Neither used nor set, do what you like with them.
	 */
	VipsRect pos;
	int x, y;

	/* Set in work to get the allocate to signal stop.
	 */
	gboolean stop;

	/* The client data passed to the enclosing vips_threadpool_run().
	 */
        void *a;

} VipsThreadState;
</STRUCT>
<STRUCT>
<NAME>VipsThreadStateClass</NAME>
typedef struct _VipsThreadStateClass {
	VipsObjectClass parent_class;
	/*< public >*/

} VipsThreadStateClass;
</STRUCT>
<FUNCTION>
<NAME>vips_thread_state_set</NAME>
<RETURNS>void  *</RETURNS>
 VipsObject *object, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_thread_state_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_thread_state_new</NAME>
<RETURNS>VipsThreadState  *</RETURNS>
 VipsImage *im, void *a 
</FUNCTION>
<USER_FUNCTION>
<NAME>VipsThreadStartFn</NAME>
<RETURNS>VipsThreadState *</RETURNS>
 VipsImage *im, void *a 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>VipsThreadpoolAllocateFn</NAME>
<RETURNS>int </RETURNS>
 VipsThreadState *state,
	void *a, gboolean *stop 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>VipsThreadpoolWorkFn</NAME>
<RETURNS>int </RETURNS>
 VipsThreadState *state, void *a 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>VipsThreadpoolProgressFn</NAME>
<RETURNS>int </RETURNS>
 void *a 
</USER_FUNCTION>
<FUNCTION>
<NAME>vips_threadpool_run</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, VipsThreadStartFn start, VipsThreadpoolAllocateFn allocate, VipsThreadpoolWorkFn work, VipsThreadpoolProgressFn progress, void *a 
</FUNCTION>
<FUNCTION>
<NAME>vips_get_tile_size</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *im, int *tile_width, int *tile_height, int *nlines 
</FUNCTION>
<FUNCTION>
<NAME>vips__print_renders</NAME>
<RETURNS>void  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_concurrency_set</NAME>
<RETURNS>void  </RETURNS>
 int concurrency 
</FUNCTION>
<FUNCTION>
<NAME>vips_concurrency_get</NAME>
<RETURNS>int  </RETURNS>
 void 
</FUNCTION>
<MACRO>
<NAME>VIPS_META_EXIF_NAME</NAME>
#define VIPS_META_EXIF_NAME "exif-data"
</MACRO>
<MACRO>
<NAME>VIPS_META_XMP_NAME</NAME>
#define VIPS_META_XMP_NAME "xmp-data"
</MACRO>
<MACRO>
<NAME>VIPS_META_ICC_NAME</NAME>
#define VIPS_META_ICC_NAME "icc-profile-data"
</MACRO>
<MACRO>
<NAME>VIPS_META_XML</NAME>
#define VIPS_META_XML "xml-header"
</MACRO>
<MACRO>
<NAME>VIPS_META_RESOLUTION_UNIT</NAME>
#define VIPS_META_RESOLUTION_UNIT "resolution-unit"
</MACRO>
<FUNCTION>
<NAME>vips_format_sizeof</NAME>
<RETURNS>int  </RETURNS>
 VipsBandFormat format 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_width</NAME>
<RETURNS>int  </RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_height</NAME>
<RETURNS>int  </RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_bands</NAME>
<RETURNS>int  </RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_format</NAME>
<RETURNS>VipsBandFormat  </RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_coding</NAME>
<RETURNS>VipsCoding  </RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_interpretation</NAME>
<RETURNS>VipsInterpretation  </RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_xres</NAME>
<RETURNS>double  </RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_yres</NAME>
<RETURNS>double  </RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_xoffset</NAME>
<RETURNS>int  </RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_yoffset</NAME>
<RETURNS>int  </RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_filename</NAME>
<RETURNS>const char  *</RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_mode</NAME>
<RETURNS>const char  *</RETURNS>
 const VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_data</NAME>
<RETURNS>void  *</RETURNS>
 VipsImage *image 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_init_fields</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, int xsize, int ysize, int bands, VipsBandFormat format, VipsCoding coding, VipsInterpretation interpretation, float xres, float yres 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_copy_fields_array</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, VipsImage *in[] 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_copy_fieldsv</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, VipsImage *in1, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_copy_fields</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, VipsImage *in 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_set</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, const char *field, GValue *value 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, const char *field, GValue *value_copy 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_as_string</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, const char *field, char **out 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_typeof</NAME>
<RETURNS>GType  </RETURNS>
 VipsImage *image, const char *field 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_remove</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsImage *image, const char *field 
</FUNCTION>
<USER_FUNCTION>
<NAME>VipsImageMapFn</NAME>
<RETURNS>void *</RETURNS>
 VipsImage *image, 
	const char *field, GValue *value, void *a 
</USER_FUNCTION>
<FUNCTION>
<NAME>vips_image_map</NAME>
<RETURNS>void  *</RETURNS>
 VipsImage *im, VipsImageMapFn fn, void *a 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_set_area</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, const char *field, VipsCallbackFn free_fn, void *data 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_area</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, const char *field, void **data 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_set_string</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, const char *field, const char *str 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_string</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, const char *field, char **str 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_set_blob</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, const char *field, VipsCallbackFn free_fn, void *data, size_t length 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_blob</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, const char *field, void **data, size_t *length 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_int</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, const char *field, int *out 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_set_int</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, const char *field, int i 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_double</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, const char *field, double *out 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_set_double</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, const char *field, double d 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_history_printf</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, const char *format, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_history_args</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, const char *name, int argc, char *argv[] 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_get_history</NAME>
<RETURNS>const char  *</RETURNS>
 VipsImage *image 
</FUNCTION>
<USER_FUNCTION>
<NAME>VipsRegionWrite</NAME>
<RETURNS>int </RETURNS>
 VipsRegion *region, VipsRect *area, void *a 
</USER_FUNCTION>
<FUNCTION>
<NAME>vips_sink_disc</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, VipsRegionWrite write_fn, void *a 
</FUNCTION>
<USER_FUNCTION>
<NAME>VipsStartFn</NAME>
<RETURNS>void *</RETURNS>
 VipsImage *out, void *a, void *b 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>VipsGenerateFn</NAME>
<RETURNS>int </RETURNS>
 VipsRegion *out, 
	void *seq, void *a, void *b, gboolean *stop 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>VipsStopFn</NAME>
<RETURNS>int </RETURNS>
 void *seq, void *a, void *b 
</USER_FUNCTION>
<FUNCTION>
<NAME>vips_sink</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, VipsStartFn start_fn, VipsGenerateFn generate_fn, VipsStopFn stop_fn, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_sink_tile</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, int tile_width, int tile_height, VipsStartFn start_fn, VipsGenerateFn generate_fn, VipsStopFn stop_fn, void *a, void *b 
</FUNCTION>
<USER_FUNCTION>
<NAME>VipsSinkNotify</NAME>
<RETURNS>void </RETURNS>
 VipsImage *im, VipsRect *rect, void *a 
</USER_FUNCTION>
<FUNCTION>
<NAME>vips_sink_screen</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, VipsImage *mask, int tile_width, int tile_height, int max_tiles, int priority, VipsSinkNotify notify, void *a 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_cache</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int width, int height, int max 
</FUNCTION>
<FUNCTION>
<NAME>vips_sink_memory</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_start_one</NAME>
<RETURNS>void  *</RETURNS>
 VipsImage *out, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_stop_one</NAME>
<RETURNS>int  </RETURNS>
 void *seq, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_start_many</NAME>
<RETURNS>void  *</RETURNS>
 VipsImage *out, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_stop_many</NAME>
<RETURNS>int  </RETURNS>
 void *seq, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_allocate_input_array</NAME>
<RETURNS>VipsImage  **</RETURNS>
 VipsImage *out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_image_generate</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, VipsStartFn start_fn, VipsGenerateFn generate_fn, VipsStopFn stop_fn, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_demand_hint_array</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, VipsDemandStyle hint, VipsImage **in 
</FUNCTION>
<FUNCTION>
<NAME>vips_demand_hint</NAME>
<RETURNS>void  </RETURNS>
 VipsImage *image, VipsDemandStyle hint, ... 
</FUNCTION>
<FUNCTION>
<NAME>im_greyc_mask</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, VipsImage *mask, int iterations, float amplitude, float sharpness, float anisotropy, float alpha, float sigma, float dl, float da, float gauss_prec, int interpolation, int fast_approx 
</FUNCTION>
<MACRO>
<NAME>VIPS_UNREF</NAME>
#define VIPS_UNREF( X ) VIPS_FREEF( g_object_unref, (X) )
</MACRO>
<ENUM>
<NAME>VipsArgumentFlags</NAME>
typedef enum {
	VIPS_ARGUMENT_NONE = 0,
	VIPS_ARGUMENT_REQUIRED = 1,
	VIPS_ARGUMENT_CONSTRUCT = 2,
	VIPS_ARGUMENT_SET_ONCE = 4,
	VIPS_ARGUMENT_INPUT = 8,
	VIPS_ARGUMENT_OUTPUT = 16
} VipsArgumentFlags;
</ENUM>
<MACRO>
<NAME>VIPS_ARGUMENT_REQUIRED_INPUT</NAME>
#define VIPS_ARGUMENT_REQUIRED_INPUT \
	(VIPS_ARGUMENT_INPUT | \
	 VIPS_ARGUMENT_REQUIRED | \
	 VIPS_ARGUMENT_CONSTRUCT) 
</MACRO>
<MACRO>
<NAME>VIPS_ARGUMENT_OPTIONAL_INPUT</NAME>
#define VIPS_ARGUMENT_OPTIONAL_INPUT \
	(VIPS_ARGUMENT_INPUT | \
	 VIPS_ARGUMENT_CONSTRUCT)
</MACRO>
<MACRO>
<NAME>VIPS_ARGUMENT_REQUIRED_OUTPUT</NAME>
#define VIPS_ARGUMENT_REQUIRED_OUTPUT \
	(VIPS_ARGUMENT_OUTPUT | \
	 VIPS_ARGUMENT_REQUIRED | \
	 VIPS_ARGUMENT_CONSTRUCT)
</MACRO>
<MACRO>
<NAME>VIPS_ARGUMENT_OPTIONAL_OUTPUT</NAME>
#define VIPS_ARGUMENT_OPTIONAL_OUTPUT \
	(VIPS_ARGUMENT_OUTPUT | \
	 VIPS_ARGUMENT_CONSTRUCT)
</MACRO>
<MACRO>
<NAME>VIPS_ARG_IMAGE</NAME>
#define VIPS_ARG_IMAGE( CLASS, NAME, PRIORITY, LONG, DESC, FLAGS, OFFSET ) { \
	GParamSpec *pspec; \
	\
	pspec = g_param_spec_object( (NAME), (LONG), (DESC),  \
		VIPS_TYPE_IMAGE, \
		G_PARAM_READWRITE ); \
	g_object_class_install_property( G_OBJECT_CLASS( CLASS ), \
		_vips__argument_id++, pspec ); \
	vips_object_class_install_argument( VIPS_OBJECT_CLASS( CLASS ), \
		pspec, (FLAGS), (PRIORITY), (OFFSET) ); \
}
</MACRO>
<MACRO>
<NAME>VIPS_ARG_BOOL</NAME>
#define VIPS_ARG_BOOL( CLASS, NAME, PRIORITY, LONG, DESC, \
	FLAGS, OFFSET, VALUE ) { \
	GParamSpec *pspec; \
	\
	pspec = g_param_spec_boolean( (NAME), (LONG), (DESC), \
		(VALUE), \
		G_PARAM_READWRITE ); \
	g_object_class_install_property( G_OBJECT_CLASS( CLASS ), \
		_vips__argument_id++, pspec ); \
	vips_object_class_install_argument( VIPS_OBJECT_CLASS( CLASS ), \
		pspec, (FLAGS), (PRIORITY), (OFFSET) ); \
}
</MACRO>
<MACRO>
<NAME>VIPS_ARG_DOUBLE</NAME>
#define VIPS_ARG_DOUBLE( CLASS, NAME, PRIORITY, LONG, DESC, \
	FLAGS, OFFSET, MIN, MAX, VALUE ) { \
	GParamSpec *pspec; \
	\
	pspec = g_param_spec_double( (NAME), (LONG), (DESC), \
		(MIN), (MAX), (VALUE), \
		G_PARAM_READWRITE );\
	g_object_class_install_property( G_OBJECT_CLASS( CLASS ), \
		_vips__argument_id++, pspec ); \
	vips_object_class_install_argument( VIPS_OBJECT_CLASS( CLASS ), \
		pspec, (FLAGS), (PRIORITY), (OFFSET) ); \
}
</MACRO>
<MACRO>
<NAME>VIPS_ARG_BOXED</NAME>
#define VIPS_ARG_BOXED( CLASS, NAME, PRIORITY, LONG, DESC, \
	FLAGS, OFFSET, TYPE ) { \
	GParamSpec *pspec; \
	\
	pspec = g_param_spec_boxed( (NAME), (LONG), (DESC), \
		(TYPE), \
		G_PARAM_READWRITE );\
	g_object_class_install_property( G_OBJECT_CLASS( CLASS ), \
		_vips__argument_id++, pspec ); \
	vips_object_class_install_argument( VIPS_OBJECT_CLASS( CLASS ), \
		pspec, (FLAGS), (PRIORITY), (OFFSET) ); \
}
</MACRO>
<MACRO>
<NAME>VIPS_ARG_INT</NAME>
#define VIPS_ARG_INT( CLASS, NAME, PRIORITY, LONG, DESC, \
	FLAGS, OFFSET, MIN, MAX, VALUE ) { \
	GParamSpec *pspec; \
	\
	pspec = g_param_spec_int( (NAME), (LONG), (DESC), \
		(MIN), (MAX), (VALUE), \
		G_PARAM_READWRITE );\
	g_object_class_install_property( G_OBJECT_CLASS( CLASS ), \
		_vips__argument_id++, pspec ); \
	vips_object_class_install_argument( VIPS_OBJECT_CLASS( CLASS ), \
		pspec, (FLAGS), (PRIORITY), (OFFSET) ); \
}
</MACRO>
<MACRO>
<NAME>VIPS_ARG_ENUM</NAME>
#define VIPS_ARG_ENUM( CLASS, NAME, PRIORITY, LONG, DESC, \
	FLAGS, OFFSET, TYPE, VALUE ) { \
	GParamSpec *pspec; \
	\
	pspec = g_param_spec_enum( (NAME), (LONG), (DESC), \
		(TYPE), (VALUE), \
		G_PARAM_READWRITE );\
	g_object_class_install_property( G_OBJECT_CLASS( CLASS ), \
		_vips__argument_id++, pspec ); \
	vips_object_class_install_argument( VIPS_OBJECT_CLASS( CLASS ), \
		pspec, (FLAGS), (PRIORITY), (OFFSET) ); \
}
</MACRO>
<MACRO>
<NAME>VIPS_ARG_STRING</NAME>
#define VIPS_ARG_STRING( CLASS, NAME, PRIORITY, LONG, DESC, FLAGS, OFFSET, \
	VALUE ) { \
	GParamSpec *pspec; \
	\
	pspec = g_param_spec_string( (NAME), (LONG), (DESC), \
		(VALUE), \
		G_PARAM_READWRITE ); \
	g_object_class_install_property( G_OBJECT_CLASS( CLASS ), \
		_vips__argument_id++, pspec ); \
	vips_object_class_install_argument( VIPS_OBJECT_CLASS( CLASS ), \
		pspec, (FLAGS), (PRIORITY), (OFFSET) ); \
}
</MACRO>
<MACRO>
<NAME>VIPS_ARG_POINTER</NAME>
#define VIPS_ARG_POINTER( CLASS, NAME, PRIORITY, LONG, DESC, FLAGS, OFFSET ) { \
	GParamSpec *pspec; \
	\
	pspec = g_param_spec_pointer( (NAME), (LONG), (DESC), \
		G_PARAM_READWRITE ); \
	g_object_class_install_property( gobject_class,  \
		_vips__argument_id++, pspec ); \
	vips_object_class_install_argument( VIPS_OBJECT_CLASS( CLASS ), \
		pspec, (FLAGS), (PRIORITY), (OFFSET) ); \
}
</MACRO>
<STRUCT>
<NAME>VipsArgument</NAME>
typedef struct _VipsArgument {
	GParamSpec *pspec;	/* pspec for this argument */

	/* More stuff, see below */
} VipsArgument;
</STRUCT>
<STRUCT>
<NAME>VipsArgumentClass</NAME>
typedef struct _VipsArgumentClass {
	VipsArgument parent;

	/* The class of the object we are an arg for.
	 */
	VipsObjectClass *object_class;

	VipsArgumentFlags flags;
	int priority;		/* Order args by this */
	guint offset;		/* G_STRUCT_OFFSET of member in object */
} VipsArgumentClass;
</STRUCT>
<STRUCT>
<NAME>VipsArgumentInstance</NAME>
typedef struct _VipsArgumentInstance {
	VipsArgument parent;

	/* The class we are part of.
	 */
	VipsArgumentClass *argument_class;

	/* The object we are attached to.
	 */
	VipsObject *object;

	/* Has been set.
	 */
	gboolean assigned;

	/* If this is an output argument, keep the id of our "close" handler
	 * here.
	 */
	gulong close_id;	
} VipsArgumentInstance;
</STRUCT>
<TYPEDEF>
<NAME>VipsArgumentTable</NAME>
typedef GHashTable VipsArgumentTable;
</TYPEDEF>
<FUNCTION>
<NAME>vips__argument_get_instance</NAME>
<RETURNS>VipsArgumentInstance  *</RETURNS>
 VipsArgumentClass *, VipsObject * 
</FUNCTION>
<FUNCTION>
<NAME>vips__argument_table_lookup</NAME>
<RETURNS>VipsArgument  *</RETURNS>
 VipsArgumentTable *, GParamSpec * 
</FUNCTION>
<FUNCTION>
<NAME>vips__object_set_member</NAME>
<RETURNS>void  </RETURNS>
 VipsObject *object, GParamSpec *pspec, GObject **member, GObject *argument 
</FUNCTION>
<USER_FUNCTION>
<NAME>VipsArgumentMapFn</NAME>
<RETURNS>void *</RETURNS>
 VipsObject *, GParamSpec *,
	VipsArgumentClass *, VipsArgumentInstance *, void *a, void *b 
</USER_FUNCTION>
<FUNCTION>
<NAME>vips_argument_map</NAME>
<RETURNS>void  *</RETURNS>
 VipsObject *object, VipsArgumentMapFn fn, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_argument_dispose_all</NAME>
<RETURNS>void  </RETURNS>
 VipsObject *object 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_get_argument</NAME>
<RETURNS>int  </RETURNS>
 VipsObject *object, const char *name, GParamSpec **pspec, VipsArgumentClass **argument_class, VipsArgumentInstance **argument_instance 
</FUNCTION>
<FUNCTION>
<NAME>vips_argument_get_assigned</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsObject *object, const char *name 
</FUNCTION>
<MACRO>
<NAME>VIPS_ARGUMENT_FOR_ALL</NAME>
#define VIPS_ARGUMENT_FOR_ALL( OBJECT, PSPEC, ARG_CLASS, ARG_INSTANCE ) { \
	VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS( OBJECT ); \
	GSList *p; \
 	\
	for( p = object_class->argument_table_traverse; p; p = p->next ) { \
		VipsArgumentClass *ARG_CLASS = \
			(VipsArgumentClass *) p->data; \
		VipsArgument *argument = (VipsArgument *) argument_class; \
		GParamSpec *PSPEC = argument->pspec; \
		VipsArgumentInstance *ARG_INSTANCE = \
			vips__argument_get_instance( argument_class, \
			VIPS_OBJECT( OBJECT ) ); \
		\
		/* We have many props on the arg table ... filter out the \
		 * ones for this class. \
		 */ \
		if( g_object_class_find_property( \
			G_OBJECT_CLASS( object_class ), \
			g_param_spec_get_name( PSPEC ) ) == PSPEC ) {
</MACRO>
<MACRO>
<NAME>VIPS_ARGUMENT_FOR_ALL_END</NAME>
#define VIPS_ARGUMENT_FOR_ALL_END } } }
</MACRO>
<MACRO>
<NAME>VIPS_TYPE_OBJECT</NAME>
#define VIPS_TYPE_OBJECT (vips_object_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_OBJECT</NAME>
#define VIPS_OBJECT( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), VIPS_TYPE_OBJECT, VipsObject ))
</MACRO>
<MACRO>
<NAME>VIPS_OBJECT_CLASS</NAME>
#define VIPS_OBJECT_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), VIPS_TYPE_OBJECT, VipsObjectClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_OBJECT</NAME>
#define VIPS_IS_OBJECT( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_OBJECT ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_OBJECT_CLASS</NAME>
#define VIPS_IS_OBJECT_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_OBJECT ))
</MACRO>
<MACRO>
<NAME>VIPS_OBJECT_GET_CLASS</NAME>
#define VIPS_OBJECT_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), VIPS_TYPE_OBJECT, VipsObjectClass ))
</MACRO>
<STRUCT>
<NAME>VipsObject</NAME>
struct _VipsObject {
	GObject parent_object;

	/* Set after ->build() has run succesfully: construct is fully done
	 * and checked.
	 */
	gboolean constructed;

	/* Set for static objects which are allocated at startup and never
	 * freed. These objects are ommitted from leak reports.
	 */
	gboolean static_object;

	/* Table of argument instances for this class and any derived classes.
	 */
	VipsArgumentTable *argument_table;

	/* Class properties (see below), duplicated in the instance so we can
	 * get at them easily via the property system.
	 */
	char *nickname;
	char *description;

	/* The pre/post/close callbacks are all fire-once. 
	 */
	gboolean preclose;
	gboolean close;
	gboolean postclose;
};
</STRUCT>
<STRUCT>
<NAME>VipsObjectClass</NAME>
struct _VipsObjectClass {
	GObjectClass parent_class;

	/* Build the object ... all argument properties have been set,
	 * now build the thing.
	 */
	int (*build)( VipsObject *object );

	/* Try to print something about the class, handy for help displays.
	 */
	void (*print_class)( struct _VipsObjectClass *, VipsBuf * );

	/* Try to print something about the object, handy for debugging.
	 */
	void (*print)( VipsObject *, VipsBuf * );

	/* Sanity-check the object. Print messages and stuff. 
	 * Handy for debugging.
	 */
	void (*sanity)( VipsObject *, VipsBuf * );

	/* Rewind. Save and restore any stuff that needs to survive a
	 * dispose().
	 */
	void (*rewind)( VipsObject * );

	/* Just before close, everything is still alive.
	 */
	void (*preclose)( VipsObject * );

	/* Close, time to free stuff.
	 */
	void (*close)( VipsObject * );

	/* Post-close, everything is dead, except the VipsObject pointer.
	 * Useful for eg. deleting the file associated with a temp image.
	 */
	void (*postclose)( VipsObject * );

	/* The CLI interface. Implement these four to get CLI input and output
	 * for your object.
	 */

	/* Given a command-line arg (eg. a filename), make an instance of the
	 * object. Just do the g_object_new(), don't call _build().
	 *
	 * Don't call this directly, see vips_object_new_from_string().
	 */
	VipsObject *(*new_from_string)( const char *string );

	/* The inverse of ^^. Given an object, output what ->new_from_string()
	 * would have been given to make that object. 
	 */
	void (*to_string)( VipsObject *, VipsBuf * ); 

	/* Does this output arg need an arg from the command line? Image
	 * output, for example, needs a filename to write to.
	 */
	gboolean output_needs_arg;

	/* Write the object to the string. Return 0 for success, or -1 on
	 * error, setting vips_error(). string is NULL if output_needs_arg()
	 * was FALSE.
	 */
	int (*output_to_arg)( VipsObject *object, const char *string );

	/* Class nickname, eg. "VipsInterpolateBicubic" has "bicubic" as a
	 * nickname. Not internationalised. 
	 */
	const char *nickname;

	/* Class description. Used for help messages, so internationalised.
	 */
	const char *description;

	/* Table of arguments for this class and any derived classes. Order
	 * is important, so keep a traverse list too. We can't rely on the
	 * ordering given by g_object_class_list_properties() since it comes
	 * from a hash :-(
	 */
	VipsArgumentTable *argument_table;
	GSList *argument_table_traverse;
};
</STRUCT>
<FUNCTION>
<NAME>vips_value_is_null</NAME>
<RETURNS>gboolean  </RETURNS>
 GParamSpec *psoec, const GValue *value 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_set_property</NAME>
<RETURNS>void  </RETURNS>
 GObject *gobject, guint property_id, const GValue *value, GParamSpec *pspec 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_get_property</NAME>
<RETURNS>void  </RETURNS>
 GObject *gobject, guint property_id, GValue *value, GParamSpec *pspec 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_preclose</NAME>
<RETURNS>void  </RETURNS>
 VipsObject *object 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_build</NAME>
<RETURNS>int  </RETURNS>
 VipsObject *object 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_print_class</NAME>
<RETURNS>void  </RETURNS>
 VipsObjectClass *klass 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_print</NAME>
<RETURNS>void  </RETURNS>
 VipsObject *object 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_print_name</NAME>
<RETURNS>void  </RETURNS>
 VipsObject *object 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_sanity</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsObject *object 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_class_install_argument</NAME>
<RETURNS>void  </RETURNS>
 VipsObjectClass *, GParamSpec *pspec, VipsArgumentFlags flags, int priority, guint offset 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_set_argument_from_string</NAME>
<RETURNS>int  </RETURNS>
 VipsObject *object, const char *name, const char *value 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_get_argument_needs_string</NAME>
<RETURNS>gboolean  </RETURNS>
 VipsObject *object, const char *name 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_get_argument_to_string</NAME>
<RETURNS>int  </RETURNS>
 VipsObject *object, const char *name, const char *arg 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_set_required</NAME>
<RETURNS>int  </RETURNS>
 VipsObject *object, const char *value 
</FUNCTION>
<USER_FUNCTION>
<NAME>VipsObjectSetArguments</NAME>
<RETURNS>void *</RETURNS>
 VipsObject *, void *, void * 
</USER_FUNCTION>
<FUNCTION>
<NAME>vips_object_new</NAME>
<RETURNS>VipsObject  *</RETURNS>
 GType type, VipsObjectSetArguments set, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_new_from_string</NAME>
<RETURNS>VipsObject  *</RETURNS>
 VipsObjectClass *object_class, const char *p 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_to_string</NAME>
<RETURNS>void  </RETURNS>
 VipsObject *object, VipsBuf *buf 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_map</NAME>
<RETURNS>void  *</RETURNS>
 VipsSListMap2Fn fn, void *a, void *b 
</FUNCTION>
<USER_FUNCTION>
<NAME>VipsTypeMap</NAME>
<RETURNS>void *</RETURNS>
 GType, void * 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>VipsTypeMap2</NAME>
<RETURNS>void *</RETURNS>
 GType, void *, void * 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>VipsClassMap</NAME>
<RETURNS>void *</RETURNS>
 VipsObjectClass *, void * 
</USER_FUNCTION>
<FUNCTION>
<NAME>vips_type_map</NAME>
<RETURNS>void  *</RETURNS>
 GType base, VipsTypeMap2 fn, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_type_map_all</NAME>
<RETURNS>void  *</RETURNS>
 GType base, VipsTypeMap fn, void *a 
</FUNCTION>
<FUNCTION>
<NAME>vips_class_map_all</NAME>
<RETURNS>void  *</RETURNS>
 GType base, VipsClassMap fn, void *a 
</FUNCTION>
<FUNCTION>
<NAME>vips_class_depth</NAME>
<RETURNS>int  </RETURNS>
 VipsObjectClass *klass 
</FUNCTION>
<FUNCTION>
<NAME>vips_class_find</NAME>
<RETURNS>VipsObjectClass  *</RETURNS>
 const char *basename, const char *nickname 
</FUNCTION>
<FUNCTION>
<NAME>vips_type_find</NAME>
<RETURNS>GType  </RETURNS>
 const char *basename, const char *nickname 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_local_array</NAME>
<RETURNS>VipsObject  **</RETURNS>
 VipsObject *parent, int n 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_local_cb</NAME>
<RETURNS>void  </RETURNS>
 VipsObject *vobject, GObject *gobject 
</FUNCTION>
<MACRO>
<NAME>vips_object_local</NAME>
#define vips_object_local( V, G ) \
	(g_signal_connect( V, "close", \
		G_CALLBACK( vips_object_local_cb ), G ), 0)
</MACRO>
<FUNCTION>
<NAME>vips_object_set_static</NAME>
<RETURNS>void  </RETURNS>
 VipsObject *object, gboolean static_object 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_print_all</NAME>
<RETURNS>void  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_sanity_all</NAME>
<RETURNS>void  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_object_rewind</NAME>
<RETURNS>void  </RETURNS>
 VipsObject *object 
</FUNCTION>
<FUNCTION>
<NAME>im_grey</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, const int xsize, const int ysize 
</FUNCTION>
<FUNCTION>
<NAME>im_fgrey</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, const int xsize, const int ysize 
</FUNCTION>
<FUNCTION>
<NAME>im_make_xy</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, const int xsize, const int ysize 
</FUNCTION>
<FUNCTION>
<NAME>im_feye</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, const int xsize, const int ysize, const double factor 
</FUNCTION>
<FUNCTION>
<NAME>im_eye</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, const int xsize, const int ysize, const double factor 
</FUNCTION>
<FUNCTION>
<NAME>im_zone</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, int size 
</FUNCTION>
<FUNCTION>
<NAME>im_fzone</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, int size 
</FUNCTION>
<FUNCTION>
<NAME>im_sines</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, int xsize, int ysize, double horfreq, double verfreq 
</FUNCTION>
<FUNCTION>
<NAME>im_benchmarkn</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n 
</FUNCTION>
<FUNCTION>
<NAME>im_benchmark2</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, double *out 
</FUNCTION>
<MACRO>
<NAME>VIPS_PI</NAME>
#define VIPS_PI (3.14159265358979323846)
</MACRO>
<MACRO>
<NAME>VIPS_RAD</NAME>
#define VIPS_RAD( R ) (((R) / 360.0) * 2.0 * VIPS_PI)
</MACRO>
<MACRO>
<NAME>VIPS_DEG</NAME>
#define VIPS_DEG( A ) (((A) / (2.0 * VIPS_PI)) * 360.0)
</MACRO>
<MACRO>
<NAME>VIPS_MAX</NAME>
#define VIPS_MAX( A, B ) ((A) > (B) ? (A) : (B))
</MACRO>
<MACRO>
<NAME>VIPS_MIN</NAME>
#define VIPS_MIN( A, B ) ((A) < (B) ? (A) : (B))
</MACRO>
<MACRO>
<NAME>VIPS_ABS</NAME>
#define VIPS_ABS( X ) (((X) >= 0) ? (X) : -(X))
</MACRO>
<MACRO>
<NAME>VIPS_CLIP</NAME>
#define VIPS_CLIP( A, V, B ) VIPS_MAX( (A), VIPS_MIN( (B), (V) ) )
</MACRO>
<MACRO>
<NAME>VIPS_NUMBER</NAME>
#define VIPS_NUMBER( R ) ((int) (sizeof(R) / sizeof(R[0])))
</MACRO>
<MACRO>
<NAME>VIPS_SWAP</NAME>
#define VIPS_SWAP( TYPE, A, B ) \
G_STMT_START { \
	TYPE t = (A); \
	(A) = (B); \
	(B) = t; \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>VIPS_UNROLL</NAME>
#define VIPS_UNROLL( N, OPER ) \
G_STMT_START { \
	if( (N) ) { \
		int duff_count = ((N) + 15) / 16; \
		\
		switch( (N) % 16 ) { \
		case 0:  do {   OPER;  \
		case 15:        OPER;  \
		case 14:        OPER;  \
		case 13:        OPER;  \
		case 12:        OPER;  \
		case 11:        OPER;  \
		case 10:        OPER;  \
		case 9:         OPER;  \
		case 8:         OPER;  \
		case 7:         OPER;  \
		case 6:         OPER;  \
		case 5:         OPER;  \
		case 4:         OPER;  \
		case 3:         OPER;  \
		case 2:         OPER;  \
		case 1: 	OPER;  \
			 } while( --duff_count > 0 ); \
		} \
	} \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>VIPS_RINT</NAME>
#define VIPS_RINT( R ) ((int) ((R) > 0 ? ((R) + 0.5) : ((R) - 0.5)))
</MACRO>
<MACRO>
<NAME>VIPS_CLIP_UCHAR</NAME>
#define VIPS_CLIP_UCHAR( V, SEQ ) \
G_STMT_START { \
	if( (V) < 0 ) {   \
		(SEQ)->underflow++;   \
		(V) = 0;   \
	}  \
	else if( (V) > UCHAR_MAX ) {   \
		(SEQ)->overflow++;   \
		(V) = UCHAR_MAX;   \
	}  \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>VIPS_CLIP_CHAR</NAME>
#define VIPS_CLIP_CHAR( V, SEQ ) \
G_STMT_START { \
	if( (V) < SCHAR_MIN ) {   \
		(SEQ)->underflow++;   \
		(V) = SCHAR_MIN;   \
	}  \
	else if( (V) > SCHAR_MAX ) {   \
		(SEQ)->overflow++;   \
		(V) = SCHAR_MAX;   \
	}  \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>VIPS_CLIP_USHORT</NAME>
#define VIPS_CLIP_USHORT( V, SEQ ) \
G_STMT_START { \
	if( (V) < 0 ) {   \
		(SEQ)->underflow++;   \
		(V) = 0;   \
	}  \
	else if( (V) > USHRT_MAX ) {   \
		(SEQ)->overflow++;   \
		(V) = USHRT_MAX;   \
	}  \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>VIPS_CLIP_SHORT</NAME>
#define VIPS_CLIP_SHORT( V, SEQ ) \
G_STMT_START { \
	if( (V) < SHRT_MIN ) {   \
		(SEQ)->underflow++;   \
		(V) = SHRT_MIN;   \
	}  \
	else if( (V) > SHRT_MAX ) {   \
		(SEQ)->overflow++;   \
		(V) = SHRT_MAX;   \
	}  \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>VIPS_CLIP_NONE</NAME>
#define VIPS_CLIP_NONE( V, SEQ ) {}
</MACRO>
<MACRO>
<NAME>VIPS_ENUM_STRING</NAME>
#define VIPS_ENUM_STRING( ENUM, VALUE ) \
	(g_enum_get_value( g_type_class_ref( ENUM ), VALUE )->value_name)
</MACRO>
<MACRO>
<NAME>VIPS_ENUM_NICK</NAME>
#define VIPS_ENUM_NICK( ENUM, VALUE ) \
	(g_enum_get_value( g_type_class_ref( ENUM ), VALUE )->value_nick)
</MACRO>
<USER_FUNCTION>
<NAME>VipsSListMap2Fn</NAME>
<RETURNS>void *</RETURNS>
 void *, void *, void * 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>VipsSListMap4Fn</NAME>
<RETURNS>void *</RETURNS>
 void *, void *, void *, void *, void * 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>VipsSListFold2Fn</NAME>
<RETURNS>void *</RETURNS>
 void *, void *, void *, void * 
</USER_FUNCTION>
<FUNCTION>
<NAME>vips_slist_equal</NAME>
<RETURNS>gboolean  </RETURNS>
 GSList *l1, GSList *l2 
</FUNCTION>
<FUNCTION>
<NAME>vips_slist_map2</NAME>
<RETURNS>void  *</RETURNS>
 GSList *list, VipsSListMap2Fn fn, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_slist_map2_rev</NAME>
<RETURNS>void  *</RETURNS>
 GSList *list, VipsSListMap2Fn fn, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_slist_map4</NAME>
<RETURNS>void  *</RETURNS>
 GSList *list, VipsSListMap4Fn fn, void *a, void *b, void *c, void *d 
</FUNCTION>
<FUNCTION>
<NAME>vips_slist_fold2</NAME>
<RETURNS>void  *</RETURNS>
 GSList *list, void *start, VipsSListFold2Fn fn, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_slist_filter</NAME>
<RETURNS>GSList  *</RETURNS>
 GSList *list, VipsSListMap2Fn fn, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_slist_free_all</NAME>
<RETURNS>void  </RETURNS>
 GSList *list 
</FUNCTION>
<FUNCTION>
<NAME>vips_map_equal</NAME>
<RETURNS>void  *</RETURNS>
 void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_hash_table_map</NAME>
<RETURNS>void  *</RETURNS>
 GHashTable *hash, VipsSListMap2Fn fn, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_strncpy</NAME>
<RETURNS>char  *</RETURNS>
 char *dest, const char *src, int n 
</FUNCTION>
<FUNCTION>
<NAME>vips_strrstr</NAME>
<RETURNS>char  *</RETURNS>
 const char *haystack, const char *needle 
</FUNCTION>
<FUNCTION>
<NAME>vips_ispostfix</NAME>
<RETURNS>gboolean  </RETURNS>
 const char *a, const char *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_isprefix</NAME>
<RETURNS>gboolean  </RETURNS>
 const char *a, const char *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_break_token</NAME>
<RETURNS>char  *</RETURNS>
 char *str, const char *brk 
</FUNCTION>
<FUNCTION>
<NAME>vips_vsnprintf</NAME>
<RETURNS>int  </RETURNS>
 char *str, size_t size, const char *format, va_list ap 
</FUNCTION>
<FUNCTION>
<NAME>vips_snprintf</NAME>
<RETURNS>int  </RETURNS>
 char *str, size_t size, const char *format, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_filename_split</NAME>
<RETURNS>void  </RETURNS>
 const char *path, char *name, char *mode 
</FUNCTION>
<FUNCTION>
<NAME>vips_skip_dir</NAME>
<RETURNS>const char  *</RETURNS>
 const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>vips_filename_suffix</NAME>
<RETURNS>void  </RETURNS>
 const char *path, char *suffix 
</FUNCTION>
<FUNCTION>
<NAME>vips_filename_suffix_match</NAME>
<RETURNS>int  </RETURNS>
 const char *path, const char *suffixes[] 
</FUNCTION>
<FUNCTION>
<NAME>vips_getnextoption</NAME>
<RETURNS>char  *</RETURNS>
 char **in 
</FUNCTION>
<FUNCTION>
<NAME>vips_getsuboption</NAME>
<RETURNS>char  *</RETURNS>
 const char *buf 
</FUNCTION>
<FUNCTION>
<NAME>vips_file_length</NAME>
<RETURNS>gint64  </RETURNS>
 int fd 
</FUNCTION>
<FUNCTION>
<NAME>vips__write</NAME>
<RETURNS>int  </RETURNS>
 int fd, const void *buf, size_t count 
</FUNCTION>
<FUNCTION>
<NAME>vips__file_open_read</NAME>
<RETURNS>FILE  *</RETURNS>
 const char *filename, const char *fallback_dir, gboolean text_mode 
</FUNCTION>
<FUNCTION>
<NAME>vips__file_open_write</NAME>
<RETURNS>FILE  *</RETURNS>
 const char *filename, gboolean text_mode 
</FUNCTION>
<FUNCTION>
<NAME>vips__file_read</NAME>
<RETURNS>char  *</RETURNS>
 FILE *fp, const char *name, unsigned int *length_out 
</FUNCTION>
<FUNCTION>
<NAME>vips__file_read_name</NAME>
<RETURNS>char  *</RETURNS>
 const char *name, const char *fallback_dir, unsigned int *length_out 
</FUNCTION>
<FUNCTION>
<NAME>vips__file_write</NAME>
<RETURNS>int  </RETURNS>
 void *data, size_t size, size_t nmemb, FILE *stream 
</FUNCTION>
<FUNCTION>
<NAME>vips__get_bytes</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, unsigned char buf[], int len 
</FUNCTION>
<FUNCTION>
<NAME>vips__gvalue_ref_string_new</NAME>
<RETURNS>GValue  *</RETURNS>
 const char *text 
</FUNCTION>
<FUNCTION>
<NAME>vips__gslist_gvalue_free</NAME>
<RETURNS>void  </RETURNS>
 GSList *list 
</FUNCTION>
<FUNCTION>
<NAME>vips__gslist_gvalue_copy</NAME>
<RETURNS>GSList  *</RETURNS>
 const GSList *list 
</FUNCTION>
<FUNCTION>
<NAME>vips__gslist_gvalue_merge</NAME>
<RETURNS>GSList  *</RETURNS>
 GSList *a, const GSList *b 
</FUNCTION>
<FUNCTION>
<NAME>vips__gslist_gvalue_get</NAME>
<RETURNS>char  *</RETURNS>
 const GSList *list 
</FUNCTION>
<FUNCTION>
<NAME>vips__seek</NAME>
<RETURNS>int  </RETURNS>
 int fd, gint64 pos 
</FUNCTION>
<FUNCTION>
<NAME>vips__ftruncate</NAME>
<RETURNS>int  </RETURNS>
 int fd, gint64 pos 
</FUNCTION>
<FUNCTION>
<NAME>vips_existsf</NAME>
<RETURNS>int  </RETURNS>
 const char *name, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_popenf</NAME>
<RETURNS>FILE  *</RETURNS>
 const char *fmt, const char *mode, ... 
</FUNCTION>
<ENUM>
<NAME>VipsToken</NAME>
typedef enum {
 	VIPS_TOKEN_LEFT = 1,
	VIPS_TOKEN_RIGHT,
	VIPS_TOKEN_STRING,
	VIPS_TOKEN_EQUALS,
	VIPS_TOKEN_COMMA
} VipsToken;
</ENUM>
<FUNCTION>
<NAME>vips__token_get</NAME>
<RETURNS>const char  *</RETURNS>
 const char *buffer, VipsToken *token, char *string, int size 
</FUNCTION>
<FUNCTION>
<NAME>vips__token_must</NAME>
<RETURNS>const char  *</RETURNS>
 const char *buffer, VipsToken *token, char *string, int size 
</FUNCTION>
<FUNCTION>
<NAME>vips__token_need</NAME>
<RETURNS>const char  *</RETURNS>
 const char *buffer, VipsToken need_token, char *string, int size 
</FUNCTION>
<FUNCTION>
<NAME>vips_ispoweroftwo</NAME>
<RETURNS>int  </RETURNS>
 int p 
</FUNCTION>
<FUNCTION>
<NAME>vips_amiMSBfirst</NAME>
<RETURNS>int  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips__temp_name</NAME>
<RETURNS>char  *</RETURNS>
 const char *format 
</FUNCTION>
<FUNCTION>
<NAME>vips__change_suffix</NAME>
<RETURNS>void  </RETURNS>
 const char *name, char *out, int mx, const char *new_suff, const char **olds, int nolds 
</FUNCTION>
<FUNCTION>
<NAME>im_draw_rect</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, int left, int top, int width, int height, int fill, PEL *ink 
</FUNCTION>
<FUNCTION>
<NAME>im_draw_circle</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, int x, int y, int radius, gboolean fill, PEL *ink 
</FUNCTION>
<FUNCTION>
<NAME>im_draw_image</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, VipsImage *sub, int x, int y 
</FUNCTION>
<USER_FUNCTION>
<NAME>VipsPlotFn</NAME>
<RETURNS>int </RETURNS>
 VipsImage *image, int x, int y, 
	void *a, void *b, void *c 
</USER_FUNCTION>
<FUNCTION>
<NAME>im_draw_line_user</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, int x1, int y1, int x2, int y2, VipsPlotFn plot, void *a, void *b, void *c 
</FUNCTION>
<FUNCTION>
<NAME>im_draw_line</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, int x1, int y1, int x2, int y2, PEL *ink 
</FUNCTION>
<FUNCTION>
<NAME>im_lineset</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, VipsImage *mask, VipsImage *ink, int n, int *x1v, int *y1v, int *x2v, int *y2v 
</FUNCTION>
<FUNCTION>
<NAME>im_draw_flood</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, int x, int y, PEL *ink, VipsRect *dout 
</FUNCTION>
<FUNCTION>
<NAME>im_draw_flood_blob</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, int x, int y, PEL *ink, VipsRect *dout 
</FUNCTION>
<FUNCTION>
<NAME>im_draw_flood_other</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, VipsImage *test, int x, int y, int serial, VipsRect *dout 
</FUNCTION>
<FUNCTION>
<NAME>im_draw_mask</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, VipsImage *mask_im, int x, int y, PEL *ink 
</FUNCTION>
<FUNCTION>
<NAME>im_draw_point</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, int x, int y, PEL *ink 
</FUNCTION>
<FUNCTION>
<NAME>im_read_point</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, int x, int y, PEL *ink 
</FUNCTION>
<FUNCTION>
<NAME>im_draw_smudge</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *image, int left, int top, int width, int height 
</FUNCTION>
<MACRO>
<NAME>VIPS_VERSION</NAME>
#define VIPS_VERSION		"7.27.0"
</MACRO>
<MACRO>
<NAME>VIPS_VERSION_STRING</NAME>
#define VIPS_VERSION_STRING	"7.27.0-Thu Nov 17 17:07:37 GMT 2011"
</MACRO>
<MACRO>
<NAME>VIPS_MAJOR_VERSION</NAME>
#define VIPS_MAJOR_VERSION	(7)
</MACRO>
<MACRO>
<NAME>VIPS_MINOR_VERSION</NAME>
#define VIPS_MINOR_VERSION	(27)
</MACRO>
<MACRO>
<NAME>VIPS_MICRO_VERSION</NAME>
#define VIPS_MICRO_VERSION	(0)
</MACRO>
<MACRO>
<NAME>VIPS_EXEEXT</NAME>
#define VIPS_EXEEXT ""
</MACRO>
<ENUM>
<NAME>VipsExtend</NAME>
typedef enum {
	VIPS_EXTEND_BLACK = 0,
	VIPS_EXTEND_COPY = 1,
	VIPS_EXTEND_REPEAT = 2,
	VIPS_EXTEND_MIRROR = 3,
	VIPS_EXTEND_WHITE = 4,
	VIPS_EXTEND_LAST = 5
} VipsExtend;
</ENUM>
<ENUM>
<NAME>VipsDirection</NAME>
typedef enum {
	VIPS_DIRECTION_HORIZONTAL,
	VIPS_DIRECTION_VERTICAL,
	VIPS_DIRECTION_LAST
} VipsDirection;
</ENUM>
<ENUM>
<NAME>VipsAlign</NAME>
typedef enum {
	VIPS_ALIGN_LOW,
	VIPS_ALIGN_CENTRE,
	VIPS_ALIGN_HIGH,
	VIPS_ALIGN_LAST
} VipsAlign;
</ENUM>
<ENUM>
<NAME>VipsAngle</NAME>
typedef enum {
	VIPS_ANGLE_0,
	VIPS_ANGLE_90,
	VIPS_ANGLE_180,
	VIPS_ANGLE_270,
	VIPS_ANGLE_LAST
} VipsAngle;
</ENUM>
<FUNCTION>
<NAME>vips_copy</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_embed</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, int x, int y, int width, int height, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_flip</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, VipsDirection direction, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_insert</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *main, VipsImage *sub, VipsImage **out, int x, int y, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_join</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *main, VipsImage *sub, VipsImage **out, VipsDirection direction, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_extract_area</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *input, VipsImage **output, int left, int top, int width, int height, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_extract_band</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *input, VipsImage **output, int band, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_replicate</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, int across, int down, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_cast</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, VipsBandFormat format, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_bandjoin</NAME>
<RETURNS>int  </RETURNS>
 VipsImage **in, VipsImage **out, int n, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_bandjoin2</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_black</NAME>
<RETURNS>int  </RETURNS>
 VipsImage **out, int width, int height, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_rot</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, VipsAngle angle, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_ifthenelse</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *cond, VipsImage *in1, VipsImage *in2, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>im_copy_file</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_scale</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_msb</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_msb_band</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int band 
</FUNCTION>
<FUNCTION>
<NAME>im_c2amph</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_c2rect</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_ri2c</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_c2imag</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_c2real</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_scaleps</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_falsecolour</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_gaussnoise</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, int x, int y, double mean, double sigma 
</FUNCTION>
<FUNCTION>
<NAME>im_text</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, const char *text, const char *font, int width, int alignment, int dpi 
</FUNCTION>
<FUNCTION>
<NAME>im_insertset</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *main, VipsImage *sub, VipsImage *out, int n, int *x, int *y 
</FUNCTION>
<FUNCTION>
<NAME>im_grid</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int tile_height, int across, int down 
</FUNCTION>
<FUNCTION>
<NAME>im_wrap</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int x, int y 
</FUNCTION>
<FUNCTION>
<NAME>im_subsample</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int xshrink, int yshrink 
</FUNCTION>
<FUNCTION>
<NAME>im_zoom</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int xfac, int yfac 
</FUNCTION>
<FUNCTION>
<NAME>im_system</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, const char *cmd, char **out 
</FUNCTION>
<FUNCTION>
<NAME>im_system_image</NAME>
<RETURNS>VipsImage  *</RETURNS>
 VipsImage *im, const char *in_format, const char *out_format, const char *cmd_format, char **log 
</FUNCTION>
<FUNCTION>
<NAME>im_affinei</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, VipsInterpolate *interpolate, double a, double b, double c, double d, double dx, double dy, int ox, int oy, int ow, int oh 
</FUNCTION>
<FUNCTION>
<NAME>im_affinei_all</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, VipsInterpolate *interpolate, double a, double b, double c, double d, double dx, double dy 
</FUNCTION>
<FUNCTION>
<NAME>im_shrink</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double xshrink, double yshrink 
</FUNCTION>
<FUNCTION>
<NAME>im_rightshift_size</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int xshift, int yshift, int band_fmt 
</FUNCTION>
<FUNCTION>
<NAME>im_match_linear</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *ref, VipsImage *sec, VipsImage *out, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2 
</FUNCTION>
<FUNCTION>
<NAME>im_match_linear_search</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *ref, VipsImage *sec, VipsImage *out, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int hwindowsize, int hsearchsize 
</FUNCTION>
<MACRO>
<NAME>IM_TYPE_IMAGEVEC</NAME>
#define IM_TYPE_IMAGEVEC "imagevec"	/* im_object is ptr to IMAGE[] */
</MACRO>
<MACRO>
<NAME>IM_TYPE_DOUBLEVEC</NAME>
#define IM_TYPE_DOUBLEVEC "doublevec"	/* im_object is ptr to double[] */
</MACRO>
<MACRO>
<NAME>IM_TYPE_INTVEC</NAME>
#define IM_TYPE_INTVEC "intvec"		/* im_object is ptr to int[] */
</MACRO>
<MACRO>
<NAME>IM_TYPE_DOUBLE</NAME>
#define IM_TYPE_DOUBLE "double"		/* im_object is ptr to double */
</MACRO>
<MACRO>
<NAME>IM_TYPE_INT</NAME>
#define IM_TYPE_INT "integer"		/* 32-bit integer */
</MACRO>
<MACRO>
<NAME>IM_TYPE_COMPLEX</NAME>
#define IM_TYPE_COMPLEX "complex"	/* Pair of doubles */
</MACRO>
<MACRO>
<NAME>IM_TYPE_STRING</NAME>
#define IM_TYPE_STRING "string"         /* Zero-terminated char array */
</MACRO>
<MACRO>
<NAME>IM_TYPE_IMASK</NAME>
#define IM_TYPE_IMASK "intmask"		/* Integer mask type */
</MACRO>
<MACRO>
<NAME>IM_TYPE_DMASK</NAME>
#define IM_TYPE_DMASK "doublemask"	/* Double mask type */
</MACRO>
<MACRO>
<NAME>IM_TYPE_IMAGE</NAME>
#define IM_TYPE_IMAGE "image"           /* IMAGE descriptor */
</MACRO>
<MACRO>
<NAME>IM_TYPE_DISPLAY</NAME>
#define IM_TYPE_DISPLAY "display"	/* Display descriptor */
</MACRO>
<MACRO>
<NAME>IM_TYPE_GVALUE</NAME>
#define IM_TYPE_GVALUE "gvalue"		/* GValue wrapper */
</MACRO>
<MACRO>
<NAME>IM_TYPE_INTERPOLATE</NAME>
#define IM_TYPE_INTERPOLATE "interpolate"/* A subclass of VipsInterpolate */
</MACRO>
<TYPEDEF>
<NAME>im_arg_type</NAME>
typedef char *im_arg_type;              /* Type of argument id */
</TYPEDEF>
<TYPEDEF>
<NAME>im_object</NAME>
typedef void *im_object;
</TYPEDEF>
<ENUM>
<NAME>im_type_flags</NAME>
typedef enum {
	IM_TYPE_NONE = 0,		/* No flags */
	IM_TYPE_OUTPUT = 0x1,		/* Output/input object */
	IM_TYPE_ARG = 0x2,		/* Uses a str arg in construction */
	IM_TYPE_RW = 0x4		/* Read-write */
} im_type_flags;
</ENUM>
<USER_FUNCTION>
<NAME>im_init_obj_fn</NAME>
<RETURNS>int </RETURNS>
 im_object *obj, char *str 
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>im_dest_obj_fn</NAME>
<RETURNS>int </RETURNS>
 im_object obj 
</USER_FUNCTION>
<STRUCT>
<NAME>im_type_desc</NAME>
typedef struct {
	im_arg_type type;		/* Type of argument */
	int size;			/* sizeof( im_object repres. ) */
	im_type_flags flags;		/* Flags */
	im_init_obj_fn init; 		/* Operation functions */
	im_dest_obj_fn dest;            /* Destroy object */
} im_type_desc;
</STRUCT>
<USER_FUNCTION>
<NAME>im_print_obj_fn</NAME>
<RETURNS>int </RETURNS>
 im_object obj 
</USER_FUNCTION>
<STRUCT>
<NAME>im_arg_desc</NAME>
typedef struct {
	char *name;			/* eg. "width" */
	im_type_desc *desc; 		/* Type description */
	im_print_obj_fn print;		/* Print some output objects */
} im_arg_desc;
</STRUCT>
<USER_FUNCTION>
<NAME>im_dispatch_fn</NAME>
<RETURNS>int </RETURNS>
 im_object *argv 
</USER_FUNCTION>
<MACRO>
<NAME>IM_MAX_ARGS</NAME>
#define IM_MAX_ARGS (1000)
</MACRO>
<ENUM>
<NAME>im_fn_flags</NAME>
typedef enum {
	IM_FN_NONE = 0,		/* No flags set */
	IM_FN_PIO = 0x1,	/* Is a partial function */
	IM_FN_TRANSFORM = 0x2,	/* Performs coordinate transformations */
	IM_FN_PTOP = 0x4,	/* Point-to-point ... can be done with a LUT */
	IM_FN_NOCACHE = 0x8	/* Result should not be cached */
} im_fn_flags;
</ENUM>
<STRUCT>
<NAME>im_function</NAME>
typedef struct {
	char *name;		/* eg "im_invert" */
	char *desc;		/* Description - eg "photographic negative" */
	im_fn_flags flags;	/* Flags for this function */
	im_dispatch_fn disp;	/* Dispatch */
	int argc;		/* Number of args */
	im_arg_desc *argv; 	/* Arg table */
} im_function;
</STRUCT>
<STRUCT>
<NAME>im_package</NAME>
typedef struct {
	char *name;		/* Package name (eg "arithmetic") */
	int nfuncs;		/* Number of functions in package */
	im_function **table;	/* Array of function descriptors */
} im_package;
</STRUCT>
<STRUCT>
<NAME>im_mask_object</NAME>
typedef struct {
	char *name;		/* Command-line name in */
	void *mask;		/* Mask --- DOUBLE or INT */
} im_mask_object;
</STRUCT>
<STRUCT>
<NAME>im_doublevec_object</NAME>
typedef struct {
	int n;			/* Vector length */
	double *vec;		/* Vector */
} im_doublevec_object;
</STRUCT>
<STRUCT>
<NAME>im_intvec_object</NAME>
typedef struct {
	int n;			/* Vector length */
	int *vec;		/* Vector */
} im_intvec_object;
</STRUCT>
<STRUCT>
<NAME>im_imagevec_object</NAME>
typedef struct {
	int n;			/* Vector length */
	IMAGE **vec;		/* Vector */
} im_imagevec_object;
</STRUCT>
<VARIABLE>
<NAME>im__input_int</NAME>
extern im_type_desc im__input_int;
</VARIABLE>
<VARIABLE>
<NAME>im__input_intvec</NAME>
extern im_type_desc im__input_intvec;
</VARIABLE>
<VARIABLE>
<NAME>im__input_imask</NAME>
extern im_type_desc im__input_imask;
</VARIABLE>
<VARIABLE>
<NAME>im__output_int</NAME>
extern im_type_desc im__output_int;
</VARIABLE>
<VARIABLE>
<NAME>im__output_intvec</NAME>
extern im_type_desc im__output_intvec;
</VARIABLE>
<VARIABLE>
<NAME>im__output_imask</NAME>
extern im_type_desc im__output_imask;
</VARIABLE>
<VARIABLE>
<NAME>im__input_double</NAME>
extern im_type_desc im__input_double;
</VARIABLE>
<VARIABLE>
<NAME>im__input_doublevec</NAME>
extern im_type_desc im__input_doublevec;
</VARIABLE>
<VARIABLE>
<NAME>im__input_dmask</NAME>
extern im_type_desc im__input_dmask;
</VARIABLE>
<VARIABLE>
<NAME>im__output_double</NAME>
extern im_type_desc im__output_double;
</VARIABLE>
<VARIABLE>
<NAME>im__output_doublevec</NAME>
extern im_type_desc im__output_doublevec;
</VARIABLE>
<VARIABLE>
<NAME>im__output_dmask</NAME>
extern im_type_desc im__output_dmask;
</VARIABLE>
<VARIABLE>
<NAME>im__output_dmask_screen</NAME>
extern im_type_desc im__output_dmask_screen;
</VARIABLE>
<VARIABLE>
<NAME>im__output_complex</NAME>
extern im_type_desc im__output_complex;
</VARIABLE>
<VARIABLE>
<NAME>im__input_string</NAME>
extern im_type_desc im__input_string;
</VARIABLE>
<VARIABLE>
<NAME>im__output_string</NAME>
extern im_type_desc im__output_string;
</VARIABLE>
<VARIABLE>
<NAME>im__input_imagevec</NAME>
extern im_type_desc im__input_imagevec;
</VARIABLE>
<VARIABLE>
<NAME>im__input_image</NAME>
extern im_type_desc im__input_image;
</VARIABLE>
<VARIABLE>
<NAME>im__output_image</NAME>
extern im_type_desc im__output_image;
</VARIABLE>
<VARIABLE>
<NAME>im__rw_image</NAME>
extern im_type_desc im__rw_image;
</VARIABLE>
<VARIABLE>
<NAME>im__input_display</NAME>
extern im_type_desc im__input_display;
</VARIABLE>
<VARIABLE>
<NAME>im__output_display</NAME>
extern im_type_desc im__output_display;
</VARIABLE>
<VARIABLE>
<NAME>im__input_gvalue</NAME>
extern im_type_desc im__input_gvalue;
</VARIABLE>
<VARIABLE>
<NAME>im__output_gvalue</NAME>
extern im_type_desc im__output_gvalue;
</VARIABLE>
<VARIABLE>
<NAME>im__input_interpolate</NAME>
extern im_type_desc im__input_interpolate;
</VARIABLE>
<FUNCTION>
<NAME>im__iprint</NAME>
<RETURNS>int  </RETURNS>
 im_object obj 
</FUNCTION>
<FUNCTION>
<NAME>im__ivprint</NAME>
<RETURNS>int  </RETURNS>
 im_object obj 
</FUNCTION>
<FUNCTION>
<NAME>im__dprint</NAME>
<RETURNS>int  </RETURNS>
 im_object obj 
</FUNCTION>
<FUNCTION>
<NAME>im__dvprint</NAME>
<RETURNS>int  </RETURNS>
 im_object obj 
</FUNCTION>
<FUNCTION>
<NAME>im__dmsprint</NAME>
<RETURNS>int  </RETURNS>
 im_object obj 
</FUNCTION>
<FUNCTION>
<NAME>im__cprint</NAME>
<RETURNS>int  </RETURNS>
 im_object obj 
</FUNCTION>
<FUNCTION>
<NAME>im__sprint</NAME>
<RETURNS>int  </RETURNS>
 im_object obj 
</FUNCTION>
<FUNCTION>
<NAME>im__displayprint</NAME>
<RETURNS>int  </RETURNS>
 im_object obj 
</FUNCTION>
<FUNCTION>
<NAME>im__gprint</NAME>
<RETURNS>int  </RETURNS>
 im_object obj 
</FUNCTION>
<MACRO>
<NAME>IM_INPUT_INT</NAME>
#define IM_INPUT_INT( S ) { S, &im__input_int, NULL }
</MACRO>
<MACRO>
<NAME>IM_INPUT_INTVEC</NAME>
#define IM_INPUT_INTVEC( S ) { S, &im__input_intvec, NULL }
</MACRO>
<MACRO>
<NAME>IM_INPUT_IMASK</NAME>
#define IM_INPUT_IMASK( S ) { S, &im__input_imask, NULL }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_INT</NAME>
#define IM_OUTPUT_INT( S ) { S, &im__output_int, im__iprint }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_INTVEC</NAME>
#define IM_OUTPUT_INTVEC( S ) { S, &im__output_intvec, im__ivprint }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_IMASK</NAME>
#define IM_OUTPUT_IMASK( S ) { S, &im__output_imask, NULL }
</MACRO>
<MACRO>
<NAME>IM_INPUT_DOUBLE</NAME>
#define IM_INPUT_DOUBLE( S ) { S, &im__input_double, NULL }
</MACRO>
<MACRO>
<NAME>IM_INPUT_DOUBLEVEC</NAME>
#define IM_INPUT_DOUBLEVEC( S ) { S, &im__input_doublevec, NULL }
</MACRO>
<MACRO>
<NAME>IM_INPUT_DMASK</NAME>
#define IM_INPUT_DMASK( S ) { S, &im__input_dmask, NULL }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_DOUBLE</NAME>
#define IM_OUTPUT_DOUBLE( S ) { S, &im__output_double, im__dprint }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_DOUBLEVEC</NAME>
#define IM_OUTPUT_DOUBLEVEC( S ) { S, &im__output_doublevec, im__dvprint }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_DMASK</NAME>
#define IM_OUTPUT_DMASK( S ) { S, &im__output_dmask, NULL }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_DMASK_STATS</NAME>
#define IM_OUTPUT_DMASK_STATS( S ) { S, &im__output_dmask_screen, im__dmsprint }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_COMPLEX</NAME>
#define IM_OUTPUT_COMPLEX( S ) { S, &im__output_complex, im__cprint }
</MACRO>
<MACRO>
<NAME>IM_INPUT_STRING</NAME>
#define IM_INPUT_STRING( S ) { S, &im__input_string, NULL }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_STRING</NAME>
#define IM_OUTPUT_STRING( S ) { S, &im__output_string, im__sprint }
</MACRO>
<MACRO>
<NAME>IM_INPUT_IMAGE</NAME>
#define IM_INPUT_IMAGE( S ) { S, &im__input_image, NULL }
</MACRO>
<MACRO>
<NAME>IM_INPUT_IMAGEVEC</NAME>
#define IM_INPUT_IMAGEVEC( S ) { S, &im__input_imagevec, NULL }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_IMAGE</NAME>
#define IM_OUTPUT_IMAGE( S ) { S, &im__output_image, NULL }
</MACRO>
<MACRO>
<NAME>IM_RW_IMAGE</NAME>
#define IM_RW_IMAGE( S ) { S, &im__rw_image, NULL }
</MACRO>
<MACRO>
<NAME>IM_INPUT_DISPLAY</NAME>
#define IM_INPUT_DISPLAY( S ) { S, &im__input_display, NULL }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_DISPLAY</NAME>
#define IM_OUTPUT_DISPLAY( S ) { S, &im__output_display, im__displayprint }
</MACRO>
<MACRO>
<NAME>IM_INPUT_GVALUE</NAME>
#define IM_INPUT_GVALUE( S ) { S, &im__input_gvalue, NULL }
</MACRO>
<MACRO>
<NAME>IM_OUTPUT_GVALUE</NAME>
#define IM_OUTPUT_GVALUE( S ) { S, &im__output_gvalue, im__gprint }
</MACRO>
<MACRO>
<NAME>IM_INPUT_INTERPOLATE</NAME>
#define IM_INPUT_INTERPOLATE( S ) { S, &im__input_interpolate, NULL }
</MACRO>
<FUNCTION>
<NAME>im_load_plugin</NAME>
<RETURNS>im_package  *</RETURNS>
 const char *name 
</FUNCTION>
<FUNCTION>
<NAME>im_load_plugins</NAME>
<RETURNS>int  </RETURNS>
 const char *fmt, ... 
</FUNCTION>
<FUNCTION>
<NAME>im_close_plugins</NAME>
<RETURNS>int  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>im_map_packages</NAME>
<RETURNS>void  *</RETURNS>
 VipsSListMap2Fn fn, void *a 
</FUNCTION>
<FUNCTION>
<NAME>im_find_function</NAME>
<RETURNS>im_function  *</RETURNS>
 const char *name 
</FUNCTION>
<FUNCTION>
<NAME>im_find_package</NAME>
<RETURNS>im_package  *</RETURNS>
 const char *name 
</FUNCTION>
<FUNCTION>
<NAME>im_package_of_function</NAME>
<RETURNS>im_package  *</RETURNS>
 const char *name 
</FUNCTION>
<FUNCTION>
<NAME>im_free_vargv</NAME>
<RETURNS>int  </RETURNS>
 im_function *fn, im_object *vargv 
</FUNCTION>
<FUNCTION>
<NAME>im_allocate_vargv</NAME>
<RETURNS>int  </RETURNS>
 im_function *fn, im_object *vargv 
</FUNCTION>
<FUNCTION>
<NAME>im_run_command</NAME>
<RETURNS>int  </RETURNS>
 char *name, int argc, char **argv 
</FUNCTION>
<STRUCT>
<NAME>VipsRect</NAME>
typedef struct _VipsRect {
	/*< public >*/
	int left;
	int top;
	int width;
	int height;
} VipsRect;
</STRUCT>
<MACRO>
<NAME>VIPS_RECT_RIGHT</NAME>
#define VIPS_RECT_RIGHT(R) ((R)->left + (R)->width)
</MACRO>
<MACRO>
<NAME>VIPS_RECT_BOTTOM</NAME>
#define VIPS_RECT_BOTTOM(R) ((R)->top + (R)->height)
</MACRO>
<MACRO>
<NAME>VIPS_RECT_HCENTRE</NAME>
#define VIPS_RECT_HCENTRE(R) ((R)->left + (R)->width / 2)
</MACRO>
<MACRO>
<NAME>VIPS_RECT_VCENTRE</NAME>
#define VIPS_RECT_VCENTRE(R) ((R)->top + (R)->height / 2)
</MACRO>
<FUNCTION>
<NAME>vips_rect_isempty</NAME>
<RETURNS>gboolean  </RETURNS>
 const VipsRect *r 
</FUNCTION>
<FUNCTION>
<NAME>vips_rect_includespoint</NAME>
<RETURNS>gboolean  </RETURNS>
 const VipsRect *r, int x, int y 
</FUNCTION>
<FUNCTION>
<NAME>vips_rect_includesrect</NAME>
<RETURNS>gboolean  </RETURNS>
 const VipsRect *r1, const VipsRect *r2 
</FUNCTION>
<FUNCTION>
<NAME>vips_rect_equalsrect</NAME>
<RETURNS>gboolean  </RETURNS>
 const VipsRect *r1, const VipsRect *r2 
</FUNCTION>
<FUNCTION>
<NAME>vips_rect_marginadjust</NAME>
<RETURNS>void  </RETURNS>
 VipsRect *r, int n 
</FUNCTION>
<FUNCTION>
<NAME>vips_rect_intersectrect</NAME>
<RETURNS>void  </RETURNS>
 const VipsRect *r1, const VipsRect *r2, VipsRect *out 
</FUNCTION>
<FUNCTION>
<NAME>vips_rect_unionrect</NAME>
<RETURNS>void  </RETURNS>
 const VipsRect *r1, const VipsRect *r2, VipsRect *out 
</FUNCTION>
<FUNCTION>
<NAME>vips_rect_dup</NAME>
<RETURNS>VipsRect  *</RETURNS>
 const VipsRect *r 
</FUNCTION>
<FUNCTION>
<NAME>vips_rect_normalise</NAME>
<RETURNS>void  </RETURNS>
 VipsRect *r 
</FUNCTION>
<STRUCT>
<NAME>VipsSemaphore</NAME>
typedef struct {
	char *name;
	int v;

	GMutex *mutex;
	GCond *cond;
} VipsSemaphore;
</STRUCT>
<FUNCTION>
<NAME>vips_semaphore_up</NAME>
<RETURNS>int  </RETURNS>
 VipsSemaphore *s 
</FUNCTION>
<FUNCTION>
<NAME>vips_semaphore_down</NAME>
<RETURNS>int  </RETURNS>
 VipsSemaphore *s 
</FUNCTION>
<FUNCTION>
<NAME>vips_semaphore_upn</NAME>
<RETURNS>int  </RETURNS>
 VipsSemaphore *s, int n 
</FUNCTION>
<FUNCTION>
<NAME>vips_semaphore_downn</NAME>
<RETURNS>int  </RETURNS>
 VipsSemaphore *s, int n 
</FUNCTION>
<FUNCTION>
<NAME>vips_semaphore_destroy</NAME>
<RETURNS>void  </RETURNS>
 VipsSemaphore *s 
</FUNCTION>
<FUNCTION>
<NAME>vips_semaphore_init</NAME>
<RETURNS>void  </RETURNS>
 VipsSemaphore *s, int v, char *name 
</FUNCTION>
<MACRO>
<NAME>IM_D93_X0</NAME>
#define IM_D93_X0 (89.7400)
</MACRO>
<MACRO>
<NAME>IM_D93_Y0</NAME>
#define IM_D93_Y0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_D93_Z0</NAME>
#define IM_D93_Z0 (130.7700)
</MACRO>
<MACRO>
<NAME>IM_D75_X0</NAME>
#define IM_D75_X0 (94.9682)
</MACRO>
<MACRO>
<NAME>IM_D75_Y0</NAME>
#define IM_D75_Y0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_D75_Z0</NAME>
#define IM_D75_Z0 (122.5710)
</MACRO>
<MACRO>
<NAME>IM_D65_X0</NAME>
#define IM_D65_X0 (95.0470)
</MACRO>
<MACRO>
<NAME>IM_D65_Y0</NAME>
#define IM_D65_Y0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_D65_Z0</NAME>
#define IM_D65_Z0 (108.8827)
</MACRO>
<MACRO>
<NAME>IM_D55_X0</NAME>
#define IM_D55_X0 (95.6831)
</MACRO>
<MACRO>
<NAME>IM_D55_Y0</NAME>
#define IM_D55_Y0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_D55_Z0</NAME>
#define IM_D55_Z0 (92.0871)
</MACRO>
<MACRO>
<NAME>IM_D50_X0</NAME>
#define IM_D50_X0 (96.4250)
</MACRO>
<MACRO>
<NAME>IM_D50_Y0</NAME>
#define IM_D50_Y0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_D50_Z0</NAME>
#define IM_D50_Z0 (82.4680)
</MACRO>
<MACRO>
<NAME>IM_A_X0</NAME>
#define IM_A_X0 (109.8503)
</MACRO>
<MACRO>
<NAME>IM_A_Y0</NAME>
#define IM_A_Y0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_A_Z0</NAME>
#define IM_A_Z0 (35.5849)
</MACRO>
<MACRO>
<NAME>IM_B_X0</NAME>
#define IM_B_X0 (99.0720)
</MACRO>
<MACRO>
<NAME>IM_B_Y0</NAME>
#define IM_B_Y0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_B_Z0</NAME>
#define IM_B_Z0 (85.2230)
</MACRO>
<MACRO>
<NAME>IM_C_X0</NAME>
#define IM_C_X0 (98.0700)
</MACRO>
<MACRO>
<NAME>IM_C_Y0</NAME>
#define IM_C_Y0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_C_Z0</NAME>
#define IM_C_Z0 (118.2300)
</MACRO>
<MACRO>
<NAME>IM_E_X0</NAME>
#define IM_E_X0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_E_Y0</NAME>
#define IM_E_Y0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_E_Z0</NAME>
#define IM_E_Z0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_D3250_X0</NAME>
#define IM_D3250_X0 (105.6590)
</MACRO>
<MACRO>
<NAME>IM_D3250_Y0</NAME>
#define IM_D3250_Y0 (100.0)
</MACRO>
<MACRO>
<NAME>IM_D3250_Z0</NAME>
#define IM_D3250_Z0 (45.8501)
</MACRO>
<FUNCTION>
<NAME>im_col_ab2Ch</NAME>
<RETURNS>void  </RETURNS>
 float a, float b, float *C, float *h 
</FUNCTION>
<FUNCTION>
<NAME>im_col_Ch2ab</NAME>
<RETURNS>void  </RETURNS>
 float C, float h, float *a, float *b 
</FUNCTION>
<FUNCTION>
<NAME>im_col_XYZ2Lab</NAME>
<RETURNS>void  </RETURNS>
 float X, float Y, float Z, float *L, float *a, float *b 
</FUNCTION>
<FUNCTION>
<NAME>im_col_Lab2XYZ</NAME>
<RETURNS>void  </RETURNS>
 float L, float a, float b, float *X, float *Y, float *Z 
</FUNCTION>
<FUNCTION>
<NAME>im_col_pythagoras</NAME>
<RETURNS>float  </RETURNS>
 float L1, float a1, float b1, float L2, float a2, float b2 
</FUNCTION>
<FUNCTION>
<NAME>im_col_make_tables_UCS</NAME>
<RETURNS>void  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>im_col_L2Lucs</NAME>
<RETURNS>float  </RETURNS>
 float L 
</FUNCTION>
<FUNCTION>
<NAME>im_col_Lucs2L</NAME>
<RETURNS>float  </RETURNS>
 float Lucs 
</FUNCTION>
<FUNCTION>
<NAME>im_col_C2Cucs</NAME>
<RETURNS>float  </RETURNS>
 float C 
</FUNCTION>
<FUNCTION>
<NAME>im_col_Cucs2C</NAME>
<RETURNS>float  </RETURNS>
 float Cucs 
</FUNCTION>
<FUNCTION>
<NAME>im_col_Ch2hucs</NAME>
<RETURNS>float  </RETURNS>
 float C, float h 
</FUNCTION>
<FUNCTION>
<NAME>im_col_Chucs2h</NAME>
<RETURNS>float  </RETURNS>
 float C, float hucs 
</FUNCTION>
<FUNCTION>
<NAME>im_col_ab2h</NAME>
<RETURNS>double  </RETURNS>
 double a, double b 
</FUNCTION>
<FUNCTION>
<NAME>im_col_dECMC</NAME>
<RETURNS>float  </RETURNS>
 float L1, float a1, float b1, float L2, float a2, float b2 
</FUNCTION>
<FUNCTION>
<NAME>im_col_dE00</NAME>
<RETURNS>float  </RETURNS>
 float L1, float a1, float b1, float L2, float a2, float b2 
</FUNCTION>
<FUNCTION>
<NAME>im_LCh2Lab</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_LabQ2XYZ</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_rad2float</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_float2rad</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_LCh2UCS</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_Lab2LCh</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_Lab2LabQ</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_Lab2LabS</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_Lab2XYZ</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_Lab2XYZ_temp</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double X0, double Y0, double Z0 
</FUNCTION>
<FUNCTION>
<NAME>im_Lab2UCS</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_LabQ2Lab</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_LabQ2LabS</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_LabS2LabQ</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_LabS2Lab</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_UCS2XYZ</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_UCS2LCh</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_UCS2Lab</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_XYZ2Lab</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_XYZ2Lab_temp</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double X0, double Y0, double Z0 
</FUNCTION>
<FUNCTION>
<NAME>im_XYZ2UCS</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_sRGB2XYZ</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_XYZ2sRGB</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_Yxy2XYZ</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_XYZ2Yxy</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_dECMC_fromLab</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_dE00_fromLab</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_dE_fromXYZ</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_dE_fromLab</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_lab_morph</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, DOUBLEMASK *mask, double L_offset, double L_scale, double a_scale, double b_scale 
</FUNCTION>
<ENUM>
<NAME>VipsIntent</NAME>
typedef enum {
	IM_INTENT_PERCEPTUAL = 0,
	IM_INTENT_RELATIVE_COLORIMETRIC,
	IM_INTENT_SATURATION,
	IM_INTENT_ABSOLUTE_COLORIMETRIC
} VipsIntent;
</ENUM>
<FUNCTION>
<NAME>im_icc_present</NAME>
<RETURNS>int  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>im_icc_transform</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, const char *input_profile_filename, const char *output_profile_filename, VipsIntent intent 
</FUNCTION>
<FUNCTION>
<NAME>im_icc_import</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, const char *input_profile_filename, VipsIntent intent 
</FUNCTION>
<FUNCTION>
<NAME>im_icc_import_embedded</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, VipsIntent intent 
</FUNCTION>
<FUNCTION>
<NAME>im_icc_export_depth</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int depth, const char *output_profile_filename, VipsIntent intent 
</FUNCTION>
<FUNCTION>
<NAME>im_icc_ac2rc</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, const char *profile_filename 
</FUNCTION>
<FUNCTION>
<NAME>vips_operation_math_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_OPERATION_MATH</NAME>
#define VIPS_TYPE_OPERATION_MATH (vips_operation_math_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_operation_math2_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_OPERATION_MATH2</NAME>
#define VIPS_TYPE_OPERATION_MATH2 (vips_operation_math2_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_operation_round_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_OPERATION_ROUND</NAME>
#define VIPS_TYPE_OPERATION_ROUND (vips_operation_round_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_operation_relational_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_OPERATION_RELATIONAL</NAME>
#define VIPS_TYPE_OPERATION_RELATIONAL (vips_operation_relational_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_operation_boolean_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_OPERATION_BOOLEAN</NAME>
#define VIPS_TYPE_OPERATION_BOOLEAN (vips_operation_boolean_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_extend_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_EXTEND</NAME>
#define VIPS_TYPE_EXTEND (vips_extend_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_direction_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_DIRECTION</NAME>
#define VIPS_TYPE_DIRECTION (vips_direction_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_align_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_ALIGN</NAME>
#define VIPS_TYPE_ALIGN (vips_align_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_angle_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_ANGLE</NAME>
#define VIPS_TYPE_ANGLE (vips_angle_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_token_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_TOKEN</NAME>
#define VIPS_TYPE_TOKEN (vips_token_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_demand_style_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_DEMAND_STYLE</NAME>
#define VIPS_TYPE_DEMAND_STYLE (vips_demand_style_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_image_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_IMAGE_TYPE</NAME>
#define VIPS_TYPE_IMAGE_TYPE (vips_image_type_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_interpretation_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_INTERPRETATION</NAME>
#define VIPS_TYPE_INTERPRETATION (vips_interpretation_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_band_format_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_BAND_FORMAT</NAME>
#define VIPS_TYPE_BAND_FORMAT (vips_band_format_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_coding_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_CODING</NAME>
#define VIPS_TYPE_CODING (vips_coding_get_type())
</MACRO>
<FUNCTION>
<NAME>vips_argument_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_ARGUMENT_FLAGS</NAME>
#define VIPS_TYPE_ARGUMENT_FLAGS (vips_argument_flags_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_TYPE_REGION</NAME>
#define VIPS_TYPE_REGION (vips_region_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_REGION</NAME>
#define VIPS_REGION( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
	VIPS_TYPE_REGION, VipsRegion ))
</MACRO>
<MACRO>
<NAME>VIPS_REGION_CLASS</NAME>
#define VIPS_REGION_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
	VIPS_TYPE_REGION, VipsRegionClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_REGION</NAME>
#define VIPS_IS_REGION( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_REGION ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_REGION_CLASS</NAME>
#define VIPS_IS_REGION_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_REGION ))
</MACRO>
<MACRO>
<NAME>VIPS_REGION_GET_CLASS</NAME>
#define VIPS_REGION_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
	VIPS_TYPE_REGION, VipsRegionClass ))
</MACRO>
<STRUCT>
<NAME>VipsRegion</NAME>
typedef struct _VipsRegion {
	VipsObject parent_object;

	/*< public >*/
	/* Users may read these two fields.
	 */
	VipsImage *im;		/* Link back to parent image */
	VipsRect valid;		/* Area of parent we can see */

	/* The rest of VipsRegion is private.
	 */
	/*< private >*/
	RegionType type;	/* What kind of attachment */
	char *data;		/* Off here to get data */
	int bpl;		/* Bytes-per-line for data */
	void *seq;		/* Sequence we are using to fill region */

	/* The thread that made this region. Used to assert() test that
	 * regions are not being shared between threads.
	 */
	GThread *thread;

	/* Ref to the window we use for this region, if any.
	 */
	VipsWindow *window;

	/* Ref to the buffer we use for this region, if any.
	 */
	VipsBuffer *buffer;

	/* The image this region is on has changed and caches need to be
	 * dropped.
	 */
	gboolean invalid;	
} VipsRegion;
</STRUCT>
<STRUCT>
<NAME>VipsRegionClass</NAME>
typedef struct _VipsRegionClass {
	VipsObjectClass parent_class;

} VipsRegionClass;
</STRUCT>
<FUNCTION>
<NAME>vips_region_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_new</NAME>
<RETURNS>VipsRegion  *</RETURNS>
 VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_buffer</NAME>
<RETURNS>int  </RETURNS>
 VipsRegion *reg, VipsRect *r 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_image</NAME>
<RETURNS>int  </RETURNS>
 VipsRegion *reg, VipsRect *r 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_region</NAME>
<RETURNS>int  </RETURNS>
 VipsRegion *reg, VipsRegion *dest, VipsRect *r, int x, int y 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_equalsregion</NAME>
<RETURNS>int  </RETURNS>
 VipsRegion *reg1, VipsRegion *reg2 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_position</NAME>
<RETURNS>int  </RETURNS>
 VipsRegion *reg, int x, int y 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_paint</NAME>
<RETURNS>void  </RETURNS>
 VipsRegion *reg, VipsRect *r, int value 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_paint_pel</NAME>
<RETURNS>void  </RETURNS>
 VipsRegion *reg, VipsRect *r, PEL *ink 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_black</NAME>
<RETURNS>void  </RETURNS>
 VipsRegion *reg 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_copy</NAME>
<RETURNS>void  </RETURNS>
 VipsRegion *reg, VipsRegion *dest, VipsRect *r, int x, int y 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_prepare</NAME>
<RETURNS>int  </RETURNS>
 VipsRegion *reg, VipsRect *r 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_prepare_to</NAME>
<RETURNS>int  </RETURNS>
 VipsRegion *reg, VipsRegion *dest, VipsRect *r, int x, int y 
</FUNCTION>
<FUNCTION>
<NAME>vips_region_prepare_many</NAME>
<RETURNS>int  </RETURNS>
 VipsRegion **reg, VipsRect *r 
</FUNCTION>
<MACRO>
<NAME>VIPS_REGION_LSKIP</NAME>
#define VIPS_REGION_LSKIP( R ) \
	((size_t)((R)->bpl))
</MACRO>
<MACRO>
<NAME>VIPS_REGION_N_ELEMENTS</NAME>
#define VIPS_REGION_N_ELEMENTS( R ) \
	((size_t)((R)->valid.width * (R)->im->Bands))
</MACRO>
<MACRO>
<NAME>VIPS_REGION_SIZEOF_LINE</NAME>
#define VIPS_REGION_SIZEOF_LINE( R ) \
	((size_t)((R)->valid.width * VIPS_IMAGE_SIZEOF_PEL( (R)->im) ))
</MACRO>
<MACRO>
<NAME>VIPS_REGION_ADDR</NAME>
#define VIPS_REGION_ADDR( R, X, Y ) \
	( (vips_rect_includespoint( &(R)->valid, (X), (Y) ))? \
	  ((R)->data + ((Y) - (R)->valid.top) * VIPS_REGION_LSKIP(R) + \
	  ((X) - (R)->valid.left) * VIPS_IMAGE_SIZEOF_PEL((R)->im)): \
	  (fprintf( stderr, \
		"VIPS_REGION_ADDR: point out of bounds, " \
		"file \"%s\", line %d\n" \
		"(point x=%d, y=%d\n" \
		" should have been within VipsRect left=%d, top=%d, " \
		"width=%d, height=%d)\n", \
		__FILE__, __LINE__, \
		(X), (Y), \
		(R)->valid.left, \
		(R)->valid.top, \
		(R)->valid.width, \
		(R)->valid.height ), abort(), (char *) NULL) \
	)
</MACRO>
<MACRO>
<NAME>VIPS_REGION_ADDR_TOPLEFT</NAME>
#define VIPS_REGION_ADDR_TOPLEFT( R ) ((R)->data)
</MACRO>
<FUNCTION>
<NAME>im_dilate</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, INTMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_erode</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, INTMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_rank</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int width, int height, int index 
</FUNCTION>
<FUNCTION>
<NAME>im_rank_image</NAME>
<RETURNS>int  </RETURNS>
 VipsImage **in, VipsImage *out, int n, int index 
</FUNCTION>
<FUNCTION>
<NAME>im_maxvalue</NAME>
<RETURNS>int  </RETURNS>
 VipsImage **in, VipsImage *out, int n 
</FUNCTION>
<FUNCTION>
<NAME>im_cntlines</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, double *nolines, int flag 
</FUNCTION>
<FUNCTION>
<NAME>im_zerox</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int sign 
</FUNCTION>
<FUNCTION>
<NAME>im_profile</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int dir 
</FUNCTION>
<FUNCTION>
<NAME>im_label_regions</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *test, VipsImage *mask, int *segments 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_FORMAT</NAME>
#define VIPS_TYPE_FORMAT (vips_format_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_FORMAT</NAME>
#define VIPS_FORMAT( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
	VIPS_TYPE_FORMAT, VipsFormat ))
</MACRO>
<MACRO>
<NAME>VIPS_FORMAT_CLASS</NAME>
#define VIPS_FORMAT_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
	VIPS_TYPE_FORMAT, VipsFormatClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_FORMAT</NAME>
#define VIPS_IS_FORMAT( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_FORMAT ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_FORMAT_CLASS</NAME>
#define VIPS_IS_FORMAT_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_FORMAT ))
</MACRO>
<MACRO>
<NAME>VIPS_FORMAT_GET_CLASS</NAME>
#define VIPS_FORMAT_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
	VIPS_TYPE_FORMAT, VipsFormatClass ))
</MACRO>
<ENUM>
<NAME>VipsFormatFlags</NAME>
typedef enum {
	VIPS_FORMAT_NONE = 0,		/* No flags set */
	VIPS_FORMAT_PARTIAL = 1,	/* Lazy read OK (eg. tiled tiff) */
	VIPS_FORMAT_BIGENDIAN = 2	/* Most-significant byte first */
} VipsFormatFlags;
</ENUM>
<STRUCT>
<NAME>VipsFormat</NAME>
typedef struct _VipsFormat {
	VipsObject parent_object;
	/*< public >*/

} VipsFormat;
</STRUCT>
<STRUCT>
<NAME>VipsFormatClass</NAME>
typedef struct _VipsFormatClass {
	VipsObjectClass parent_class;

	/*< public >*/
	/* Is a file in this format.
	 */
	gboolean (*is_a)( const char * );

	/* Read just the header into the VipsImage.
	 */
	int (*header)( const char *, VipsImage * );

	/* Load the whole image.
	 */
	int (*load)( const char *, VipsImage * );

	/* Write the VipsImage to the file in this format.
	 */
	int (*save)( VipsImage *, const char * );

	/* Get the flags for this file in this format.
	 */
	VipsFormatFlags (*get_flags)( const char * );

	/* Loop over formats in this order, default 0. We need this because
	 * some formats can be read by several loaders (eg. tiff can be read
	 * by the libMagick loader as well as by the tiff loader), and we want
	 * to make sure the better loader comes first.
	 */
	int priority;

	/* Null-terminated list of allowed suffixes, eg. ".tif", ".tiff".
	 */
	const char **suffs;
} VipsFormatClass;
</STRUCT>
<FUNCTION>
<NAME>vips_format_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_format_map</NAME>
<RETURNS>void  *</RETURNS>
 VipsSListMap2Fn fn, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>vips_format_for_file</NAME>
<RETURNS>VipsFormatClass  *</RETURNS>
 const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>vips_format_for_name</NAME>
<RETURNS>VipsFormatClass  *</RETURNS>
 const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>vips_format_get_flags</NAME>
<RETURNS>VipsFormatFlags  </RETURNS>
 VipsFormatClass *format, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>vips_format_read</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>vips_format_write</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_jpeg2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_bufjpeg2vips</NAME>
<RETURNS>int  </RETURNS>
 void *buf, size_t len, VipsImage *out, gboolean header_only 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2jpeg</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2mimejpeg</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, int qfac 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2bufjpeg</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int qfac, char **obuf, int *olen 
</FUNCTION>
<FUNCTION>
<NAME>im_tiff2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2tiff</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_tile_cache</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int tile_width, int tile_height, int max_tiles 
</FUNCTION>
<FUNCTION>
<NAME>im_magick2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_exr2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_ppm2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2ppm</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_analyze2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_csv2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2csv</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_png2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2png</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2bufpng</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int compression, int interlace, char **obuf, size_t *olen 
</FUNCTION>
<FUNCTION>
<NAME>im_raw2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out, int width, int height, int bpp, int offset 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2raw</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, int fd 
</FUNCTION>
<FUNCTION>
<NAME>im_mat2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_rad2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2rad</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_fits2vips</NAME>
<RETURNS>int  </RETURNS>
 const char *filename, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2fits</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, const char *filename 
</FUNCTION>
<MACRO>
<NAME>VIPS_TYPE_INTERPOLATE</NAME>
#define VIPS_TYPE_INTERPOLATE (vips_interpolate_get_type())
</MACRO>
<MACRO>
<NAME>VIPS_INTERPOLATE</NAME>
#define VIPS_INTERPOLATE( obj ) \
	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
	VIPS_TYPE_INTERPOLATE, VipsInterpolate ))
</MACRO>
<MACRO>
<NAME>VIPS_INTERPOLATE_CLASS</NAME>
#define VIPS_INTERPOLATE_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_CAST( (klass), \
	VIPS_TYPE_INTERPOLATE, VipsInterpolateClass))
</MACRO>
<MACRO>
<NAME>VIPS_IS_INTERPOLATE</NAME>
#define VIPS_IS_INTERPOLATE( obj ) \
	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_INTERPOLATE ))
</MACRO>
<MACRO>
<NAME>VIPS_IS_INTERPOLATE_CLASS</NAME>
#define VIPS_IS_INTERPOLATE_CLASS( klass ) \
	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_INTERPOLATE ))
</MACRO>
<MACRO>
<NAME>VIPS_INTERPOLATE_GET_CLASS</NAME>
#define VIPS_INTERPOLATE_GET_CLASS( obj ) \
	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
	VIPS_TYPE_INTERPOLATE, VipsInterpolateClass ))
</MACRO>
<STRUCT>
<NAME>VipsInterpolate</NAME>
typedef struct _VipsInterpolate {
	VipsObject parent_object;

} VipsInterpolate;
</STRUCT>
<USER_FUNCTION>
<NAME>VipsInterpolateMethod</NAME>
<RETURNS>void </RETURNS>
 VipsInterpolate *interpolate,
	PEL *out, VipsRegion *in, double x, double y 
</USER_FUNCTION>
<STRUCT>
<NAME>VipsInterpolateClass</NAME>
typedef struct _VipsInterpolateClass {
	VipsObjectClass parent_class;

	/* Write to pixel out(x,y), interpolating from in(x,y). The caller has
	 * to set the regions up.
	 */
	VipsInterpolateMethod interpolate;

	/* This interpolator needs a window this many pixels across and down.
	 */
	int (*get_window_size)( VipsInterpolate * );

	/* Or just set this if you want a constant.
	 */
	int window_size;

	/* Stencils are offset by this much. Default to window_size / 2 - 1
	 * (centering) if get_window_offset is NULL and window_offset is -1.
	 */
	int (*get_window_offset)( VipsInterpolate * );
	int window_offset;
} VipsInterpolateClass;
</STRUCT>
<FUNCTION>
<NAME>vips_interpolate_get_type</NAME>
<RETURNS>GType  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_interpolate</NAME>
<RETURNS>void  </RETURNS>
 VipsInterpolate *interpolate, PEL *out, VipsRegion *in, double x, double y 
</FUNCTION>
<FUNCTION>
<NAME>vips_interpolate_get_method</NAME>
<RETURNS>VipsInterpolateMethod  </RETURNS>
 VipsInterpolate *interpolate 
</FUNCTION>
<FUNCTION>
<NAME>vips_interpolate_get_window_size</NAME>
<RETURNS>int  </RETURNS>
 VipsInterpolate *interpolate 
</FUNCTION>
<FUNCTION>
<NAME>vips_interpolate_get_window_offset</NAME>
<RETURNS>int  </RETURNS>
 VipsInterpolate *interpolate 
</FUNCTION>
<MACRO>
<NAME>VIPS_TRANSFORM_SHIFT</NAME>
#define VIPS_TRANSFORM_SHIFT (6)
</MACRO>
<MACRO>
<NAME>VIPS_TRANSFORM_SCALE</NAME>
#define VIPS_TRANSFORM_SCALE (1 << VIPS_TRANSFORM_SHIFT)
</MACRO>
<MACRO>
<NAME>VIPS_INTERPOLATE_SHIFT</NAME>
#define VIPS_INTERPOLATE_SHIFT (12)
</MACRO>
<MACRO>
<NAME>VIPS_INTERPOLATE_SCALE</NAME>
#define VIPS_INTERPOLATE_SCALE (1 << VIPS_INTERPOLATE_SHIFT)
</MACRO>
<FUNCTION>
<NAME>vips_interpolate_nearest_static</NAME>
<RETURNS>VipsInterpolate  *</RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_interpolate_bilinear_static</NAME>
<RETURNS>VipsInterpolate  *</RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_interpolate_new</NAME>
<RETURNS>VipsInterpolate  *</RETURNS>
 const char *nickname 
</FUNCTION>
<MACRO>
<NAME>VIPS_FREEF</NAME>
#define VIPS_FREEF( F, S ) \
G_STMT_START { \
        if( S ) { \
                (void) F( (S) ); \
                (S) = 0; \
        } \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>VIPS_FREE</NAME>
#define VIPS_FREE( S ) VIPS_FREEF( g_free, (S) );
</MACRO>
<MACRO>
<NAME>VIPS_SETSTR</NAME>
#define VIPS_SETSTR( S, V ) \
G_STMT_START { \
        const char *sst = (V); \
	\
        if( (S) != sst ) { \
                if( !(S) || !sst || strcmp( (S), sst ) != 0 ) { \
                        VIPS_FREE( S ); \
                        if( sst ) \
                                (S) = g_strdup( sst ); \
                } \
        } \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>VIPS_NEW</NAME>
#define VIPS_NEW( OBJ, T ) \
	((T *) vips_malloc( VIPS_OBJECT( OBJ ), sizeof( T )))
</MACRO>
<MACRO>
<NAME>VIPS_ARRAY</NAME>
#define VIPS_ARRAY( OBJ, N, T ) \
	((T *) vips_malloc( VIPS_OBJECT( OBJ ), (N) * sizeof( T )))
</MACRO>
<FUNCTION>
<NAME>vips_malloc</NAME>
<RETURNS>void  *</RETURNS>
 VipsObject *object, size_t size 
</FUNCTION>
<FUNCTION>
<NAME>vips_strdup</NAME>
<RETURNS>char  *</RETURNS>
 VipsObject *object, const char *str 
</FUNCTION>
<FUNCTION>
<NAME>vips_free</NAME>
<RETURNS>int  </RETURNS>
 void *buf 
</FUNCTION>
<FUNCTION>
<NAME>vips_tracked_free</NAME>
<RETURNS>void  </RETURNS>
 void *s 
</FUNCTION>
<FUNCTION>
<NAME>vips_tracked_malloc</NAME>
<RETURNS>void  *</RETURNS>
 size_t size 
</FUNCTION>
<FUNCTION>
<NAME>vips_tracked_get_mem</NAME>
<RETURNS>size_t  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_tracked_get_mem_highwater</NAME>
<RETURNS>size_t  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_tracked_get_allocs</NAME>
<RETURNS>int  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_tracked_open</NAME>
<RETURNS>int  </RETURNS>
 const char *pathname, int flags, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_tracked_close</NAME>
<RETURNS>int  </RETURNS>
 int fd 
</FUNCTION>
<FUNCTION>
<NAME>vips_tracked_get_files</NAME>
<RETURNS>int  </RETURNS>
 void 
</FUNCTION>
<STRUCT>
<NAME>Transformation</NAME>
typedef struct {
	/* Area of input we can use. This can be smaller than the real input 
	 * image: we expand the input to add extra pixels for interpolation. 
	 */
	VipsRect iarea;			

	/* The area of the output we've been asked to generate. left/top can
	 * be negative.
	 */
	VipsRect oarea;

	/* The transform.
	 */
	double a, b, c, d;		
	double dx, dy;

	double ia, ib, ic, id;		/* Inverse of matrix abcd */
} Transformation;
</STRUCT>
<FUNCTION>
<NAME>im__transform_init</NAME>
<RETURNS>void  </RETURNS>
 Transformation *trn 
</FUNCTION>
<FUNCTION>
<NAME>im__transform_calc_inverse</NAME>
<RETURNS>int  </RETURNS>
 Transformation *trn 
</FUNCTION>
<FUNCTION>
<NAME>im__transform_isidentity</NAME>
<RETURNS>int  </RETURNS>
 const Transformation *trn 
</FUNCTION>
<FUNCTION>
<NAME>im__transform_add</NAME>
<RETURNS>int  </RETURNS>
 const Transformation *in1, const Transformation *in2, Transformation *out 
</FUNCTION>
<FUNCTION>
<NAME>im__transform_print</NAME>
<RETURNS>void  </RETURNS>
 const Transformation *trn 
</FUNCTION>
<FUNCTION>
<NAME>im__transform_forward_point</NAME>
<RETURNS>void  </RETURNS>
 const Transformation *trn, const double x, const double y, double *ox, double *oy 
</FUNCTION>
<FUNCTION>
<NAME>im__transform_invert_point</NAME>
<RETURNS>void  </RETURNS>
 const Transformation *trn, const double x, const double y, double *ox, double *oy 
</FUNCTION>
<FUNCTION>
<NAME>im__transform_forward_rect</NAME>
<RETURNS>void  </RETURNS>
 const Transformation *trn, const VipsRect *in, VipsRect *out 
</FUNCTION>
<FUNCTION>
<NAME>im__transform_invert_rect</NAME>
<RETURNS>void  </RETURNS>
 const Transformation *trn, const VipsRect *in, VipsRect *out 
</FUNCTION>
<FUNCTION>
<NAME>im__transform_set_area</NAME>
<RETURNS>void  </RETURNS>
 Transformation * 
</FUNCTION>
<FUNCTION>
<NAME>im__affine</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, Transformation *trn 
</FUNCTION>
<FUNCTION>
<NAME>vips_error_buffer</NAME>
<RETURNS>const char  *</RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_error_clear</NAME>
<RETURNS>void  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_error</NAME>
<RETURNS>void  </RETURNS>
 const char *domain, const char *fmt, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_verror</NAME>
<RETURNS>void  </RETURNS>
 const char *domain, const char *fmt, va_list ap 
</FUNCTION>
<FUNCTION>
<NAME>vips_error_system</NAME>
<RETURNS>void  </RETURNS>
 int err, const char *domain, const char *fmt, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_verror_system</NAME>
<RETURNS>void  </RETURNS>
 int err, const char *domain, const char *fmt, va_list ap 
</FUNCTION>
<FUNCTION>
<NAME>vips_error_g</NAME>
<RETURNS>void  </RETURNS>
 GError **error 
</FUNCTION>
<FUNCTION>
<NAME>vips_warn</NAME>
<RETURNS>void  </RETURNS>
 const char *domain, const char *fmt, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_vwarn</NAME>
<RETURNS>void  </RETURNS>
 const char *domain, const char *fmt, va_list ap 
</FUNCTION>
<FUNCTION>
<NAME>vips_diag</NAME>
<RETURNS>void  </RETURNS>
 const char *domain, const char *fmt, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_vdiag</NAME>
<RETURNS>void  </RETURNS>
 const char *domain, const char *fmt, va_list ap 
</FUNCTION>
<FUNCTION>
<NAME>vips_error_exit</NAME>
<RETURNS>void  </RETURNS>
 const char *fmt, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_uncoded</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_coding_known</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_coding_labq</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_coding_rad</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_coding_noneorlabq</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_coding_same</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im1, VipsImage *im2 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_mono</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_bands_1or3</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *in 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_bands</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im, int bands 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_bands_1orn</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im1, VipsImage *im2 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_bands_1orn_unary</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im, int n 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_bands_same</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im1, VipsImage *im2 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_bandno</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im, int bandno 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_int</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_uint</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_uintorf</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_noncomplex</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_complex</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_format</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im, VipsBandFormat fmt 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_u8or16</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_8or16</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_u8or16orf</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_format_same</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im1, VipsImage *im2 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_size_same</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im1, VipsImage *im2 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_vector</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, int n, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_hist</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_imask</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, INTMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_dmask</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, DOUBLEMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_dmask_1d</NAME>
<RETURNS>int  </RETURNS>
 const char *domain, DOUBLEMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_aconvsep</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, DOUBLEMASK *mask, int n_layers 
</FUNCTION>
<FUNCTION>
<NAME>im_aconv</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, DOUBLEMASK *mask, int n_layers, int cluster 
</FUNCTION>
<FUNCTION>
<NAME>im_conv</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, INTMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_conv_f</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, DOUBLEMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_convsep</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, INTMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_convsep_f</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, DOUBLEMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_compass</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, INTMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_gradient</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, INTMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_lindetect</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, INTMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_sharpen</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int mask_size, double x1, double y2, double y3, double m1, double m2 
</FUNCTION>
<FUNCTION>
<NAME>im_grad_x</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_grad_y</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_fastcor</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *ref, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_spcor</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *ref, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_gradcor</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *ref, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_contrast_surface</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int half_win_size, int spacing 
</FUNCTION>
<FUNCTION>
<NAME>im_addgnoise</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double sigma 
</FUNCTION>
<STRUCT>
<NAME>INTMASK</NAME>
typedef struct im__INTMASK {
	int xsize;
	int ysize;
	int scale;
	int offset;
	int *coeff;
	char *filename;
} INTMASK;
</STRUCT>
<STRUCT>
<NAME>DOUBLEMASK</NAME>
typedef struct im__DOUBLEMASK {
	int xsize;
	int ysize;
	double scale;
	double offset;
	double *coeff;
	char *filename;
} DOUBLEMASK;
</STRUCT>
<FUNCTION>
<NAME>im_create_imask</NAME>
<RETURNS>INTMASK  *</RETURNS>
 const char *filename, int xsize, int ysize 
</FUNCTION>
<FUNCTION>
<NAME>im_create_imaskv</NAME>
<RETURNS>INTMASK  *</RETURNS>
 const char *filename, int xsize, int ysize, ... 
</FUNCTION>
<FUNCTION>
<NAME>im_create_dmask</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 const char *filename, int xsize, int ysize 
</FUNCTION>
<FUNCTION>
<NAME>im_create_dmaskv</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 const char *filename, int xsize, int ysize, ... 
</FUNCTION>
<FUNCTION>
<NAME>im_read_imask</NAME>
<RETURNS>INTMASK  *</RETURNS>
 const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_read_dmask</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_print_imask</NAME>
<RETURNS>void  </RETURNS>
 INTMASK *in 
</FUNCTION>
<FUNCTION>
<NAME>im_print_dmask</NAME>
<RETURNS>void  </RETURNS>
 DOUBLEMASK *in 
</FUNCTION>
<FUNCTION>
<NAME>im_write_imask</NAME>
<RETURNS>int  </RETURNS>
 INTMASK *in 
</FUNCTION>
<FUNCTION>
<NAME>im_write_dmask</NAME>
<RETURNS>int  </RETURNS>
 DOUBLEMASK *in 
</FUNCTION>
<FUNCTION>
<NAME>im_write_imask_name</NAME>
<RETURNS>int  </RETURNS>
 INTMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_write_dmask_name</NAME>
<RETURNS>int  </RETURNS>
 DOUBLEMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_free_imask</NAME>
<RETURNS>int  </RETURNS>
 INTMASK *in 
</FUNCTION>
<FUNCTION>
<NAME>im_free_dmask</NAME>
<RETURNS>int  </RETURNS>
 DOUBLEMASK *in 
</FUNCTION>
<FUNCTION>
<NAME>im_log_imask</NAME>
<RETURNS>INTMASK  *</RETURNS>
 const char *filename, double sigma, double min_ampl 
</FUNCTION>
<FUNCTION>
<NAME>im_log_dmask</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 const char *filename, double sigma, double min_ampl 
</FUNCTION>
<FUNCTION>
<NAME>im_gauss_imask</NAME>
<RETURNS>INTMASK  *</RETURNS>
 const char *filename, double sigma, double min_ampl 
</FUNCTION>
<FUNCTION>
<NAME>im_gauss_imask_sep</NAME>
<RETURNS>INTMASK  *</RETURNS>
 const char *filename, double sigma, double min_ampl 
</FUNCTION>
<FUNCTION>
<NAME>im_gauss_dmask</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 const char *filename, double sigma, double min_ampl 
</FUNCTION>
<FUNCTION>
<NAME>im_gauss_dmask_sep</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 const char *filename, double sigma, double min_ampl 
</FUNCTION>
<FUNCTION>
<NAME>im_dup_imask</NAME>
<RETURNS>INTMASK  *</RETURNS>
 INTMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_dup_dmask</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 DOUBLEMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_scale_dmask</NAME>
<RETURNS>INTMASK  *</RETURNS>
 DOUBLEMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_norm_dmask</NAME>
<RETURNS>void  </RETURNS>
 DOUBLEMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_imask2dmask</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 INTMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_dmask2imask</NAME>
<RETURNS>INTMASK  *</RETURNS>
 DOUBLEMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_rotate_imask90</NAME>
<RETURNS>INTMASK  *</RETURNS>
 INTMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_rotate_imask45</NAME>
<RETURNS>INTMASK  *</RETURNS>
 INTMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_rotate_dmask90</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 DOUBLEMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_rotate_dmask45</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 DOUBLEMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_mattrn</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 DOUBLEMASK *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_matcat</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 DOUBLEMASK *top, DOUBLEMASK *bottom, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_matmul</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 DOUBLEMASK *in1, DOUBLEMASK *in2, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_lu_decomp</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 const DOUBLEMASK *mat, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_lu_solve</NAME>
<RETURNS>int  </RETURNS>
 const DOUBLEMASK *lu, double *vec 
</FUNCTION>
<FUNCTION>
<NAME>im_matinv</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 const DOUBLEMASK *mat, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_matinv_inplace</NAME>
<RETURNS>int  </RETURNS>
 DOUBLEMASK *mat 
</FUNCTION>
<FUNCTION>
<NAME>im_local_dmask</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 struct _VipsImage *out, DOUBLEMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>im_local_imask</NAME>
<RETURNS>INTMASK  *</RETURNS>
 struct _VipsImage *out, INTMASK *mask 
</FUNCTION>
<FUNCTION>
<NAME>vips_get_argv0</NAME>
<RETURNS>const char  *</RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_init</NAME>
<RETURNS>int  </RETURNS>
 const char *argv0 
</FUNCTION>
<FUNCTION>
<NAME>vips_check_init</NAME>
<RETURNS>void  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_shutdown</NAME>
<RETURNS>void  </RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_get_option_group</NAME>
<RETURNS>GOptionGroup  *</RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_version_string</NAME>
<RETURNS>const char  *</RETURNS>
 void 
</FUNCTION>
<FUNCTION>
<NAME>vips_version</NAME>
<RETURNS>int  </RETURNS>
 int flag 
</FUNCTION>
<FUNCTION>
<NAME>vips_guess_prefix</NAME>
<RETURNS>const char  *</RETURNS>
 const char *argv0, const char *env_name 
</FUNCTION>
<FUNCTION>
<NAME>vips_guess_libdir</NAME>
<RETURNS>const char  *</RETURNS>
 const char *argv0, const char *env_name 
</FUNCTION>
<MACRO>
<NAME>VIPS_VIP7COMPATS_H</NAME>
#define VIPS_VIP7COMPATS_H
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_NOTSET</NAME>
#define IM_BANDFMT_NOTSET VIPS_FORMAT_NOTSET
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_UCHAR</NAME>
#define IM_BANDFMT_UCHAR VIPS_FORMAT_UCHAR
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_CHAR</NAME>
#define IM_BANDFMT_CHAR VIPS_FORMAT_CHAR
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_USHORT</NAME>
#define IM_BANDFMT_USHORT VIPS_FORMAT_USHORT
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_SHORT</NAME>
#define IM_BANDFMT_SHORT VIPS_FORMAT_SHORT
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_UINT</NAME>
#define IM_BANDFMT_UINT VIPS_FORMAT_UINT
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_INT</NAME>
#define IM_BANDFMT_INT VIPS_FORMAT_INT
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_FLOAT</NAME>
#define IM_BANDFMT_FLOAT VIPS_FORMAT_FLOAT
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_COMPLEX</NAME>
#define IM_BANDFMT_COMPLEX VIPS_FORMAT_COMPLEX
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_DOUBLE</NAME>
#define IM_BANDFMT_DOUBLE VIPS_FORMAT_DOUBLE
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_DPCOMPLEX</NAME>
#define IM_BANDFMT_DPCOMPLEX VIPS_FORMAT_DPCOMPLEX
</MACRO>
<MACRO>
<NAME>IM_BANDFMT_LAST</NAME>
#define IM_BANDFMT_LAST VIPS_FORMAT_LAST
</MACRO>
<MACRO>
<NAME>VipsBandFmt</NAME>
#define VipsBandFmt VipsBandFormat
</MACRO>
<MACRO>
<NAME>IM_SMALLTILE</NAME>
#define IM_SMALLTILE VIPS_DEMAND_STYLE_SMALLTILE
</MACRO>
<MACRO>
<NAME>IM_FATSTRIP</NAME>
#define IM_FATSTRIP VIPS_DEMAND_STYLE_FATSTRIP
</MACRO>
<MACRO>
<NAME>IM_THINSTRIP</NAME>
#define IM_THINSTRIP VIPS_DEMAND_STYLE_THINSTRIP
</MACRO>
<MACRO>
<NAME>IM_ANY</NAME>
#define IM_ANY VIPS_DEMAND_STYLE_ANY
</MACRO>
<MACRO>
<NAME>IM_CODING_NONE</NAME>
#define IM_CODING_NONE VIPS_CODING_NONE
</MACRO>
<MACRO>
<NAME>IM_CODING_LABQ</NAME>
#define IM_CODING_LABQ VIPS_CODING_LABQ
</MACRO>
<MACRO>
<NAME>IM_CODING_RAD</NAME>
#define IM_CODING_RAD VIPS_CODING_RAD
</MACRO>
<MACRO>
<NAME>IM_TYPE_MULTIBAND</NAME>
#define IM_TYPE_MULTIBAND VIPS_INTERPRETATION_MULTIBAND
</MACRO>
<MACRO>
<NAME>IM_TYPE_B_W</NAME>
#define IM_TYPE_B_W VIPS_INTERPRETATION_B_W
</MACRO>
<MACRO>
<NAME>IM_TYPE_HISTOGRAM</NAME>
#define IM_TYPE_HISTOGRAM VIPS_INTERPRETATION_HISTOGRAM
</MACRO>
<MACRO>
<NAME>IM_TYPE_FOURIER</NAME>
#define IM_TYPE_FOURIER VIPS_INTERPRETATION_FOURIER
</MACRO>
<MACRO>
<NAME>IM_TYPE_XYZ</NAME>
#define IM_TYPE_XYZ VIPS_INTERPRETATION_XYZ
</MACRO>
<MACRO>
<NAME>IM_TYPE_LAB</NAME>
#define IM_TYPE_LAB VIPS_INTERPRETATION_LAB
</MACRO>
<MACRO>
<NAME>IM_TYPE_CMYK</NAME>
#define IM_TYPE_CMYK VIPS_INTERPRETATION_CMYK
</MACRO>
<MACRO>
<NAME>IM_TYPE_LABQ</NAME>
#define IM_TYPE_LABQ VIPS_INTERPRETATION_LABQ
</MACRO>
<MACRO>
<NAME>IM_TYPE_RGB</NAME>
#define IM_TYPE_RGB VIPS_INTERPRETATION_RGB
</MACRO>
<MACRO>
<NAME>IM_TYPE_UCS</NAME>
#define IM_TYPE_UCS VIPS_INTERPRETATION_UCS
</MACRO>
<MACRO>
<NAME>IM_TYPE_LCH</NAME>
#define IM_TYPE_LCH VIPS_INTERPRETATION_LCH
</MACRO>
<MACRO>
<NAME>IM_TYPE_LABS</NAME>
#define IM_TYPE_LABS VIPS_INTERPRETATION_LABS
</MACRO>
<MACRO>
<NAME>IM_TYPE_sRGB</NAME>
#define IM_TYPE_sRGB VIPS_INTERPRETATION_sRGB
</MACRO>
<MACRO>
<NAME>IM_TYPE_YXY</NAME>
#define IM_TYPE_YXY VIPS_INTERPRETATION_YXY
</MACRO>
<MACRO>
<NAME>IM_TYPE_RGB16</NAME>
#define IM_TYPE_RGB16 VIPS_INTERPRETATION_RGB16
</MACRO>
<MACRO>
<NAME>IM_TYPE_GREY16</NAME>
#define IM_TYPE_GREY16 VIPS_INTERPRETATION_GREY16
</MACRO>
<MACRO>
<NAME>VipsType</NAME>
#define VipsType VipsInterpretation
</MACRO>
<MACRO>
<NAME>IMAGE</NAME>
#define IMAGE VipsImage
</MACRO>
<MACRO>
<NAME>REGION</NAME>
#define REGION VipsRegion
</MACRO>
<MACRO>
<NAME>IM_MAX</NAME>
#define IM_MAX VIPS_MAX
</MACRO>
<MACRO>
<NAME>IM_MIN</NAME>
#define IM_MIN VIPS_MIN
</MACRO>
<MACRO>
<NAME>IM_RAD</NAME>
#define IM_RAD VIPS_RAD
</MACRO>
<MACRO>
<NAME>IM_DEG</NAME>
#define IM_DEG VIPS_DEG
</MACRO>
<MACRO>
<NAME>IM_PI</NAME>
#define IM_PI VIPS_PI
</MACRO>
<MACRO>
<NAME>IM_RINT</NAME>
#define IM_RINT VIPS_RINT
</MACRO>
<MACRO>
<NAME>IM_ABS</NAME>
#define IM_ABS VIPS_ABS
</MACRO>
<MACRO>
<NAME>IM_NUMBER</NAME>
#define IM_NUMBER VIPS_NUMBER
</MACRO>
<MACRO>
<NAME>IM_CLIP</NAME>
#define IM_CLIP VIPS_CLIP
</MACRO>
<MACRO>
<NAME>IM_CLIP_UCHAR</NAME>
#define IM_CLIP_UCHAR VIPS_CLIP_UCHAR
</MACRO>
<MACRO>
<NAME>IM_CLIP_CHAR</NAME>
#define IM_CLIP_CHAR VIPS_CLIP_CHAR
</MACRO>
<MACRO>
<NAME>IM_CLIP_USHORT</NAME>
#define IM_CLIP_USHORT VIPS_CLIP_USHORT
</MACRO>
<MACRO>
<NAME>IM_CLIP_SHORT</NAME>
#define IM_CLIP_SHORT VIPS_CLIP_SHORT
</MACRO>
<MACRO>
<NAME>IM_CLIP_NONE</NAME>
#define IM_CLIP_NONE VIPS_CLIP_NONE
</MACRO>
<MACRO>
<NAME>IM_UNROLL</NAME>
#define IM_UNROLL VIPS_UNROLL
</MACRO>
<MACRO>
<NAME>IM_SWAP</NAME>
#define IM_SWAP VIPS_SWAP
</MACRO>
<MACRO>
<NAME>IM_IMAGE_ADDR</NAME>
#define IM_IMAGE_ADDR VIPS_IMAGE_ADDR
</MACRO>
<MACRO>
<NAME>IM_IMAGE_N_ELEMENTS</NAME>
#define IM_IMAGE_N_ELEMENTS VIPS_IMAGE_N_ELEMENTS
</MACRO>
<MACRO>
<NAME>IM_IMAGE_SIZEOF_ELEMENT</NAME>
#define IM_IMAGE_SIZEOF_ELEMENT VIPS_IMAGE_SIZEOF_ELEMENT
</MACRO>
<MACRO>
<NAME>IM_IMAGE_SIZEOF_PEL</NAME>
#define IM_IMAGE_SIZEOF_PEL VIPS_IMAGE_SIZEOF_PEL
</MACRO>
<MACRO>
<NAME>IM_IMAGE_SIZEOF_LINE</NAME>
#define IM_IMAGE_SIZEOF_LINE VIPS_IMAGE_SIZEOF_LINE
</MACRO>
<MACRO>
<NAME>IM_REGION_LSKIP</NAME>
#define IM_REGION_LSKIP VIPS_REGION_LSKIP
</MACRO>
<MACRO>
<NAME>IM_REGION_ADDR</NAME>
#define IM_REGION_ADDR VIPS_REGION_ADDR
</MACRO>
<MACRO>
<NAME>IM_REGION_ADDR_TOPLEFT</NAME>
#define IM_REGION_ADDR_TOPLEFT VIPS_REGION_ADDR_TOPLEFT
</MACRO>
<MACRO>
<NAME>IM_REGION_N_ELEMENTS</NAME>
#define IM_REGION_N_ELEMENTS VIPS_REGION_N_ELEMENTS
</MACRO>
<MACRO>
<NAME>IM_REGION_SIZEOF_LINE</NAME>
#define IM_REGION_SIZEOF_LINE VIPS_REGION_SIZEOF_LINE
</MACRO>
<MACRO>
<NAME>im__sizeof_bandfmt</NAME>
#define im__sizeof_bandfmt vips__image_sizeof_bandformat
</MACRO>
<MACRO>
<NAME>im_error</NAME>
#define im_error vips_error
</MACRO>
<MACRO>
<NAME>im_verror</NAME>
#define im_verror vips_verror
</MACRO>
<MACRO>
<NAME>im_verror_system</NAME>
#define im_verror_system vips_verror_system
</MACRO>
<MACRO>
<NAME>im_error_system</NAME>
#define im_error_system vips_error_system
</MACRO>
<MACRO>
<NAME>im_error_buffer</NAME>
#define im_error_buffer vips_error_buffer
</MACRO>
<MACRO>
<NAME>im_error_clear</NAME>
#define im_error_clear vips_error_clear
</MACRO>
<MACRO>
<NAME>im_warn</NAME>
#define im_warn vips_warn
</MACRO>
<MACRO>
<NAME>im_vwarn</NAME>
#define im_vwarn vips_vwarn
</MACRO>
<MACRO>
<NAME>im_diag</NAME>
#define im_diag vips_diag
</MACRO>
<MACRO>
<NAME>im_vdiag</NAME>
#define im_vdiag vips_vdiag
</MACRO>
<MACRO>
<NAME>error_exit</NAME>
#define error_exit vips_error_exit
</MACRO>
<MACRO>
<NAME>im_get_argv0</NAME>
#define im_get_argv0 vips_get_argv0
</MACRO>
<MACRO>
<NAME>im_version_string</NAME>
#define im_version_string vips_version_string
</MACRO>
<MACRO>
<NAME>im_version</NAME>
#define im_version vips_version
</MACRO>
<MACRO>
<NAME>im_init_world</NAME>
#define im_init_world vips_init
</MACRO>
<MACRO>
<NAME>im_get_option_group</NAME>
#define im_get_option_group vips_get_option_group
</MACRO>
<MACRO>
<NAME>im_guess_prefix</NAME>
#define im_guess_prefix vips_guess_prefix
</MACRO>
<MACRO>
<NAME>im_guess_libdir</NAME>
#define im_guess_libdir vips_guess_libdir
</MACRO>
<MACRO>
<NAME>im__global_lock</NAME>
#define im__global_lock vips__global_lock
</MACRO>
<MACRO>
<NAME>im_cp_desc</NAME>
#define im_cp_desc vips_image_copy_fields
</MACRO>
<MACRO>
<NAME>im_cp_descv</NAME>
#define im_cp_descv vips_image_copy_fieldsv
</MACRO>
<MACRO>
<NAME>im_cp_desc_array</NAME>
#define im_cp_desc_array vips_image_copy_fields_array
</MACRO>
<MACRO>
<NAME>im_image</NAME>
#define im_image vips_image_new_from_memory
</MACRO>
<MACRO>
<NAME>im_binfile</NAME>
#define im_binfile vips_image_new_from_file_raw
</MACRO>
<MACRO>
<NAME>im__open_temp</NAME>
#define im__open_temp vips_image_new_disc_temp
</MACRO>
<MACRO>
<NAME>im__test_kill</NAME>
#define im__test_kill( I ) (vips_image_get_kill( I ))
</MACRO>
<MACRO>
<NAME>im__start_eval</NAME>
#define im__start_eval( I ) (vips_image_preeval( I ), vips_image_get_kill( I ))
</MACRO>
<MACRO>
<NAME>im__handle_eval</NAME>
#define im__handle_eval( I, W, H ) \
	(vips_image_eval( I, W, H ), vips_image_get_kill( I ))
</MACRO>
<MACRO>
<NAME>im__end_eval</NAME>
#define im__end_eval vips_image_posteval
</MACRO>
<MACRO>
<NAME>im_invalidate</NAME>
#define im_invalidate vips_image_invalidate_all
</MACRO>
<MACRO>
<NAME>im_isfile</NAME>
#define im_isfile vips_image_isfile
</MACRO>
<MACRO>
<NAME>im_printdesc</NAME>
#define im_printdesc( I ) vips_object_print( VIPS_OBJECT( I ) )
</MACRO>
<MACRO>
<NAME>im_openout</NAME>
#define im_openout( F ) vips_image_new_mode( F, "w" )
</MACRO>
<MACRO>
<NAME>im_setbuf</NAME>
#define im_setbuf( F ) vips_image_new( "t" )
</MACRO>
<MACRO>
<NAME>im_initdesc</NAME>
#define im_initdesc( image, \
	xsize, ysize, bands, bandbits, bandfmt, coding, \
	type, xres, yres, xo, yo ) \
	vips_image_init_fields( image, \
		xsize, ysize, bands, bandfmt, coding, \
		type, xres, yres )
</MACRO>
<MACRO>
<NAME>im__open_image_file</NAME>
#define im__open_image_file vips__open_image_read
</MACRO>
<MACRO>
<NAME>im_setupout</NAME>
#define im_setupout( I ) vips__image_write_prepare( I )
</MACRO>
<MACRO>
<NAME>im_writeline</NAME>
#define im_writeline( Y, IM, P ) vips_image_write_line( IM, Y, P )
</MACRO>
<MACRO>
<NAME>im_prepare</NAME>
#define im_prepare vips_region_prepare
</MACRO>
<MACRO>
<NAME>im_prepare_to</NAME>
#define im_prepare_to vips_region_prepare_to
</MACRO>
<MACRO>
<NAME>im_region_create</NAME>
#define im_region_create vips_region_new
</MACRO>
<MACRO>
<NAME>im_region_free</NAME>
#define im_region_free g_object_unref
</MACRO>
<MACRO>
<NAME>im_region_region</NAME>
#define im_region_region vips_region_region
</MACRO>
<MACRO>
<NAME>im_region_buffer</NAME>
#define im_region_buffer vips_region_buffer
</MACRO>
<MACRO>
<NAME>im_region_black</NAME>
#define im_region_black vips_region_black
</MACRO>
<MACRO>
<NAME>im_region_paint</NAME>
#define im_region_paint vips_region_paint
</MACRO>
<MACRO>
<NAME>im_prepare_many</NAME>
#define im_prepare_many vips_region_prepare_many
</MACRO>
<MACRO>
<NAME>im__region_no_ownership</NAME>
#define im__region_no_ownership vips__region_no_ownership
</MACRO>
<MACRO>
<NAME>im_image_sanity</NAME>
#define im_image_sanity( I ) (!vips_object_sanity( VIPS_OBJECT( I ) ))
</MACRO>
<MACRO>
<NAME>im_image_sanity_all</NAME>
#define im_image_sanity_all vips_object_sanity_all
</MACRO>
<MACRO>
<NAME>im__print_all</NAME>
#define im__print_all vips_object_print_all
</MACRO>
<FUNCTION>
<NAME>im_open</NAME>
<RETURNS>VipsImage  *</RETURNS>
 const char *filename, const char *mode 
</FUNCTION>
<FUNCTION>
<NAME>im_open_local</NAME>
<RETURNS>VipsImage  *</RETURNS>
 VipsImage *parent, const char *filename, const char *mode 
</FUNCTION>
<FUNCTION>
<NAME>im_open_local_array</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *parent, VipsImage **images, int n, const char *filename, const char *mode 
</FUNCTION>
<MACRO>
<NAME>im_callback_fn</NAME>
#define im_callback_fn VipsCallbackFn
</MACRO>
<FUNCTION>
<NAME>im_add_callback</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, const char *callback, im_callback_fn fn, void *a, void *b 
</FUNCTION>
<FUNCTION>
<NAME>im_add_callback1</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, const char *callback, im_callback_fn fn, void *a, void *b 
</FUNCTION>
<MACRO>
<NAME>im_add_close_callback</NAME>
#define im_add_close_callback( IM, FN, A, B ) \
	im_add_callback( IM, "close", FN, A, B )
</MACRO>
<MACRO>
<NAME>im_add_postclose_callback</NAME>
#define im_add_postclose_callback( IM, FN, A, B ) \
	im_add_callback( IM, "postclose", FN, A, B )
</MACRO>
<MACRO>
<NAME>im_add_preclose_callback</NAME>
#define im_add_preclose_callback( IM, FN, A, B ) \
	im_add_callback( IM, "preclose", FN, A, B )
</MACRO>
<MACRO>
<NAME>im_add_evalstart_callback</NAME>
#define im_add_evalstart_callback( IM, FN, A, B ) \
	im_add_callback1( IM, "preeval", FN, A, B )
</MACRO>
<MACRO>
<NAME>im_add_evalend_callback</NAME>
#define im_add_evalend_callback( IM, FN, A, B ) \
	im_add_callback1( IM, "posteval", FN, A, B )
</MACRO>
<MACRO>
<NAME>im_add_eval_callback</NAME>
#define im_add_eval_callback( IM, FN, A, B ) \
	(vips_image_set_progress( IM, TRUE ), \
	im_add_callback1( IM, "eval", FN, A, B ))
</MACRO>
<MACRO>
<NAME>im_add_invalidate_callback</NAME>
#define im_add_invalidate_callback( IM, FN, A, B ) \
	im_add_callback( IM, "invalidate", FN, A, B )
</MACRO>
<MACRO>
<NAME>im_bits_of_fmt</NAME>
#define im_bits_of_fmt( fmt ) (vips_format_sizeof( fmt ) << 3)
</MACRO>
<USER_FUNCTION>
<NAME>im_construct_fn</NAME>
<RETURNS>void *</RETURNS>
 void *, void *, void * 
</USER_FUNCTION>
<FUNCTION>
<NAME>im_local</NAME>
<RETURNS>void  *</RETURNS>
 VipsImage *im, im_construct_fn cons, im_callback_fn dest, void *a, void *b, void *c 
</FUNCTION>
<FUNCTION>
<NAME>im_local_array</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, void **out, int n, im_construct_fn cons, im_callback_fn dest, void *a, void *b, void *c 
</FUNCTION>
<FUNCTION>
<NAME>im_close</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im 
</FUNCTION>
<FUNCTION>
<NAME>im_init</NAME>
<RETURNS>VipsImage  *</RETURNS>
 const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_Type2char</NAME>
<RETURNS>const char  *</RETURNS>
 VipsInterpretation type 
</FUNCTION>
<FUNCTION>
<NAME>im_BandFmt2char</NAME>
<RETURNS>const char  *</RETURNS>
 VipsBandFormat fmt 
</FUNCTION>
<FUNCTION>
<NAME>im_Coding2char</NAME>
<RETURNS>const char  *</RETURNS>
 VipsCoding coding 
</FUNCTION>
<FUNCTION>
<NAME>im_Compression2char</NAME>
<RETURNS>const char  *</RETURNS>
 int n 
</FUNCTION>
<FUNCTION>
<NAME>im_dtype2char</NAME>
<RETURNS>const char  *</RETURNS>
 VipsImageType n 
</FUNCTION>
<FUNCTION>
<NAME>im_dhint2char</NAME>
<RETURNS>const char  *</RETURNS>
 VipsDemandStyle style 
</FUNCTION>
<FUNCTION>
<NAME>im_char2Type</NAME>
<RETURNS>VipsInterpretation  </RETURNS>
 const char *str 
</FUNCTION>
<FUNCTION>
<NAME>im_char2BandFmt</NAME>
<RETURNS>VipsBandFormat  </RETURNS>
 const char *str 
</FUNCTION>
<FUNCTION>
<NAME>im_char2Coding</NAME>
<RETURNS>VipsCoding  </RETURNS>
 const char *str 
</FUNCTION>
<FUNCTION>
<NAME>im_char2dtype</NAME>
<RETURNS>VipsImageType  </RETURNS>
 const char *str 
</FUNCTION>
<FUNCTION>
<NAME>im_char2dhint</NAME>
<RETURNS>VipsDemandStyle  </RETURNS>
 const char *str 
</FUNCTION>
<MACRO>
<NAME>Rect</NAME>
#define Rect VipsRect
</MACRO>
<MACRO>
<NAME>IM_RECT_RIGHT</NAME>
#define IM_RECT_RIGHT VIPS_RECT_RIGHT
</MACRO>
<MACRO>
<NAME>IM_RECT_BOTTOM</NAME>
#define IM_RECT_BOTTOM VIPS_RECT_BOTTOM
</MACRO>
<MACRO>
<NAME>IM_RECT_HCENTRE</NAME>
#define IM_RECT_HCENTRE VIPS_RECT_HCENTRE
</MACRO>
<MACRO>
<NAME>IM_RECT_VCENTRE</NAME>
#define IM_RECT_VCENTRE VIPS_RECT_VCENTRE
</MACRO>
<MACRO>
<NAME>im_rect_marginadjust</NAME>
#define im_rect_marginadjust vips_rect_marginadjust
</MACRO>
<MACRO>
<NAME>im_rect_includespoint</NAME>
#define im_rect_includespoint vips_rect_includespoint
</MACRO>
<MACRO>
<NAME>im_rect_includesrect</NAME>
#define im_rect_includesrect vips_rect_includesrect
</MACRO>
<MACRO>
<NAME>im_rect_intersectrect</NAME>
#define im_rect_intersectrect vips_rect_intersectrect
</MACRO>
<MACRO>
<NAME>im_rect_isempty</NAME>
#define im_rect_isempty vips_rect_isempty
</MACRO>
<MACRO>
<NAME>im_rect_unionrect</NAME>
#define im_rect_unionrect vips_rect_unionrect
</MACRO>
<MACRO>
<NAME>im_rect_equalsrect</NAME>
#define im_rect_equalsrect vips_rect_equalsrect
</MACRO>
<MACRO>
<NAME>im_rect_dup</NAME>
#define im_rect_dup vips_rect_dup
</MACRO>
<MACRO>
<NAME>im_rect_normalise</NAME>
#define im_rect_normalise vips_rect_normalise
</MACRO>
<FUNCTION>
<NAME>im_demand_hint</NAME>
<RETURNS>int  </RETURNS>
IMAGE * im, VipsDemandStyle hint, ... 
</FUNCTION>
<MACRO>
<NAME>im_demand_hint_array</NAME>
#define im_demand_hint_array( A, B, C ) (vips_demand_hint_array( A, B, C ), 0)
</MACRO>
<MACRO>
<NAME>im_start_one</NAME>
#define im_start_one vips_start_one
</MACRO>
<MACRO>
<NAME>im_stop_one</NAME>
#define im_stop_one vips_stop_one
</MACRO>
<MACRO>
<NAME>im_start_many</NAME>
#define im_start_many vips_start_many
</MACRO>
<MACRO>
<NAME>im_stop_many</NAME>
#define im_stop_many vips_stop_many
</MACRO>
<MACRO>
<NAME>im_allocate_input_array</NAME>
#define im_allocate_input_array vips_allocate_input_array
</MACRO>
<MACRO>
<NAME>im_start_fn</NAME>
#define im_start_fn VipsStartFn
</MACRO>
<USER_FUNCTION>
<NAME>im_generate_fn</NAME>
<RETURNS>int </RETURNS>
 VipsRegion *out, void *seq, void *a, void *b 
</USER_FUNCTION>
<MACRO>
<NAME>im_stop_fn</NAME>
#define im_stop_fn VipsStopFn
</MACRO>
<FUNCTION>
<NAME>im_generate</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, im_start_fn start, im_generate_fn generate, im_stop_fn stop, void *a, void *b 
</FUNCTION>
<MACRO>
<NAME>im__mmap</NAME>
#define im__mmap vips__mmap
</MACRO>
<MACRO>
<NAME>im__munmap</NAME>
#define im__munmap vips__munmap
</MACRO>
<MACRO>
<NAME>im_mapfile</NAME>
#define im_mapfile vips_mapfile
</MACRO>
<MACRO>
<NAME>im_mapfilerw</NAME>
#define im_mapfilerw vips_mapfilerw
</MACRO>
<MACRO>
<NAME>im_remapfilerw</NAME>
#define im_remapfilerw vips_remapfilerw
</MACRO>
<MACRO>
<NAME>im__print_renders</NAME>
#define im__print_renders vips__print_renders
</MACRO>
<MACRO>
<NAME>im_cache</NAME>
#define im_cache vips_image_cache
</MACRO>
<MACRO>
<NAME>IM_FREEF</NAME>
#define IM_FREEF( F, S ) \
G_STMT_START { \
        if( S ) { \
                (void) F( (S) ); \
                (S) = 0; \
        } \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>IM_FREE</NAME>
#define IM_FREE( S ) \
G_STMT_START { \
        if( S ) { \
                (void) im_free( (void *) (S) ); \
                (S) = 0; \
        } \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>IM_SETSTR</NAME>
#define IM_SETSTR( S, V ) \
G_STMT_START { \
        const char *sst = (V); \
	\
        if( (S) != sst ) { \
                if( !(S) || !sst || strcmp( (S), sst ) != 0 ) { \
                        IM_FREE( S ); \
                        if( sst ) \
                                (S) = im_strdup( NULL, sst ); \
                } \
        } \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>im_malloc</NAME>
#define im_malloc( IM, SZ ) \
	(vips_malloc( VIPS_OBJECT( IM ), (SZ) ))
</MACRO>
<MACRO>
<NAME>im_free</NAME>
#define im_free vips_free
</MACRO>
<MACRO>
<NAME>im_strdup</NAME>
#define im_strdup( IM, STR ) \
	(vips_strdup( VIPS_OBJECT( IM ), (STR) ))
</MACRO>
<MACRO>
<NAME>IM_NEW</NAME>
#define IM_NEW( IM, T ) ((T *) im_malloc( (IM), sizeof( T )))
</MACRO>
<MACRO>
<NAME>IM_ARRAY</NAME>
#define IM_ARRAY( IM, N, T ) ((T *) im_malloc( (IM), (N) * sizeof( T )))
</MACRO>
<MACRO>
<NAME>im_incheck</NAME>
#define im_incheck vips_image_wio_input
</MACRO>
<MACRO>
<NAME>im_outcheck</NAME>
#define im_outcheck vips_image_wio_output
</MACRO>
<MACRO>
<NAME>im_rwcheck</NAME>
#define im_rwcheck vips_image_inplace
</MACRO>
<MACRO>
<NAME>im_pincheck</NAME>
#define im_pincheck vips_image_pio_input
</MACRO>
<MACRO>
<NAME>im_poutcheck</NAME>
#define im_poutcheck vips_image_pio_output
</MACRO>
<MACRO>
<NAME>im_iocheck</NAME>
#define im_iocheck( I, O ) (im_incheck( I ) || im_outcheck( O ))
</MACRO>
<MACRO>
<NAME>im_piocheck</NAME>
#define im_piocheck( I, O ) (im_pincheck( I ) || im_poutcheck( O ))
</MACRO>
<MACRO>
<NAME>im_check_uncoded</NAME>
#define im_check_uncoded vips_check_uncoded 
</MACRO>
<MACRO>
<NAME>im_check_coding_known</NAME>
#define im_check_coding_known vips_check_coding_known 
</MACRO>
<MACRO>
<NAME>im_check_coding_labq</NAME>
#define im_check_coding_labq vips_check_coding_labq 
</MACRO>
<MACRO>
<NAME>im_check_coding_rad</NAME>
#define im_check_coding_rad vips_check_coding_rad 
</MACRO>
<MACRO>
<NAME>im_check_coding_noneorlabq</NAME>
#define im_check_coding_noneorlabq vips_check_coding_noneorlabq 
</MACRO>
<MACRO>
<NAME>im_check_coding_same</NAME>
#define im_check_coding_same vips_check_coding_same 
</MACRO>
<MACRO>
<NAME>im_check_mono</NAME>
#define im_check_mono vips_check_mono 
</MACRO>
<MACRO>
<NAME>im_check_bands_1or3</NAME>
#define im_check_bands_1or3 vips_check_bands_1or3 
</MACRO>
<MACRO>
<NAME>im_check_bands</NAME>
#define im_check_bands vips_check_bands 
</MACRO>
<MACRO>
<NAME>im_check_bands_1orn</NAME>
#define im_check_bands_1orn vips_check_bands_1orn 
</MACRO>
<MACRO>
<NAME>im_check_bands_1orn_unary</NAME>
#define im_check_bands_1orn_unary vips_check_bands_1orn_unary 
</MACRO>
<MACRO>
<NAME>im_check_bands_same</NAME>
#define im_check_bands_same vips_check_bands_same 
</MACRO>
<MACRO>
<NAME>im_check_bandno</NAME>
#define im_check_bandno vips_check_bandno 
</MACRO>
<MACRO>
<NAME>im_check_int</NAME>
#define im_check_int vips_check_int 
</MACRO>
<MACRO>
<NAME>im_check_uint</NAME>
#define im_check_uint vips_check_uint 
</MACRO>
<MACRO>
<NAME>im_check_uintorf</NAME>
#define im_check_uintorf vips_check_uintorf 
</MACRO>
<MACRO>
<NAME>im_check_noncomplex</NAME>
#define im_check_noncomplex vips_check_noncomplex 
</MACRO>
<MACRO>
<NAME>im_check_complex</NAME>
#define im_check_complex vips_check_complex 
</MACRO>
<MACRO>
<NAME>im_check_format</NAME>
#define im_check_format vips_check_format 
</MACRO>
<MACRO>
<NAME>im_check_u8or16</NAME>
#define im_check_u8or16 vips_check_u8or16 
</MACRO>
<MACRO>
<NAME>im_check_8or16</NAME>
#define im_check_8or16 vips_check_8or16 
</MACRO>
<MACRO>
<NAME>im_check_u8or16orf</NAME>
#define im_check_u8or16orf vips_check_u8or16orf 
</MACRO>
<MACRO>
<NAME>im_check_format_same</NAME>
#define im_check_format_same vips_check_format_same 
</MACRO>
<MACRO>
<NAME>im_check_size_same</NAME>
#define im_check_size_same vips_check_size_same 
</MACRO>
<MACRO>
<NAME>im_check_vector</NAME>
#define im_check_vector vips_check_vector 
</MACRO>
<MACRO>
<NAME>im_check_hist</NAME>
#define im_check_hist vips_check_hist 
</MACRO>
<MACRO>
<NAME>im_check_imask</NAME>
#define im_check_imask vips_check_imask 
</MACRO>
<MACRO>
<NAME>im_check_dmask</NAME>
#define im_check_dmask vips_check_dmask 
</MACRO>
<MACRO>
<NAME>vips_bandfmt_isint</NAME>
#define vips_bandfmt_isint vips_band_format_isint 
</MACRO>
<MACRO>
<NAME>vips_bandfmt_isuint</NAME>
#define vips_bandfmt_isuint vips_band_format_isuint 
</MACRO>
<MACRO>
<NAME>vips_bandfmt_isfloat</NAME>
#define vips_bandfmt_isfloat vips_band_format_isfloat 
</MACRO>
<MACRO>
<NAME>vips_bandfmt_iscomplex</NAME>
#define vips_bandfmt_iscomplex vips_band_format_iscomplex 
</MACRO>
<MACRO>
<NAME>im__change_suffix</NAME>
#define im__change_suffix vips__change_suffix
</MACRO>
<USER_FUNCTION>
<NAME>im_wrapone_fn</NAME>
<RETURNS>void </RETURNS>
 void *in, void *out, int width,
	void *a, void *b 
</USER_FUNCTION>
<FUNCTION>
<NAME>im_wrapone</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, im_wrapone_fn fn, void *a, void *b 
</FUNCTION>
<USER_FUNCTION>
<NAME>im_wraptwo_fn</NAME>
<RETURNS>void </RETURNS>
 void *in1, void *in2, void *out, 
        int width, void *a, void *b 
</USER_FUNCTION>
<FUNCTION>
<NAME>im_wraptwo</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out, im_wraptwo_fn fn, void *a, void *b 
</FUNCTION>
<USER_FUNCTION>
<NAME>im_wrapmany_fn</NAME>
<RETURNS>void </RETURNS>
 void **in, void *out, int width,
	void *a, void *b 
</USER_FUNCTION>
<FUNCTION>
<NAME>im_wrapmany</NAME>
<RETURNS>int  </RETURNS>
 VipsImage **in, VipsImage *out, im_wrapmany_fn fn, void *a, void *b 
</FUNCTION>
<MACRO>
<NAME>IM_META_EXIF_NAME</NAME>
#define IM_META_EXIF_NAME VIPS_META_EXIF_NAME 
</MACRO>
<MACRO>
<NAME>IM_META_ICC_NAME</NAME>
#define IM_META_ICC_NAME VIPS_META_ICC_NAME 
</MACRO>
<MACRO>
<NAME>IM_META_XML</NAME>
#define IM_META_XML VIPS_META_XML 
</MACRO>
<MACRO>
<NAME>IM_META_RESOLUTION_UNIT</NAME>
#define IM_META_RESOLUTION_UNIT VIPS_META_RESOLUTION_UNIT 
</MACRO>
<MACRO>
<NAME>IM_TYPE_SAVE_STRING</NAME>
#define IM_TYPE_SAVE_STRING VIPS_TYPE_SAVE_STRING 
</MACRO>
<MACRO>
<NAME>IM_TYPE_BLOB</NAME>
#define IM_TYPE_BLOB VIPS_TYPE_BLOB 
</MACRO>
<MACRO>
<NAME>IM_TYPE_AREA</NAME>
#define IM_TYPE_AREA VIPS_TYPE_AREA 
</MACRO>
<MACRO>
<NAME>IM_TYPE_REF_STRING</NAME>
#define IM_TYPE_REF_STRING VIPS_TYPE_REF_STRING 
</MACRO>
<MACRO>
<NAME>im_header_map_fn</NAME>
#define im_header_map_fn VipsImageMapFn
</MACRO>
<MACRO>
<NAME>im_header_map</NAME>
#define im_header_map vips_image_map
</MACRO>
<MACRO>
<NAME>im_header_int</NAME>
#define im_header_int vips_image_get_int
</MACRO>
<MACRO>
<NAME>im_header_double</NAME>
#define im_header_double vips_image_get_double
</MACRO>
<MACRO>
<NAME>im_header_string</NAME>
#define im_header_string vips_image_get_string
</MACRO>
<MACRO>
<NAME>im_header_as_string</NAME>
#define im_header_as_string vips_image_get_as_string
</MACRO>
<MACRO>
<NAME>im_header_get_typeof</NAME>
#define im_header_get_typeof vips_image_get_typeof
</MACRO>
<MACRO>
<NAME>im_header_get</NAME>
#define im_header_get vips_image_get
</MACRO>
<MACRO>
<NAME>im_histlin</NAME>
#define im_histlin vips_image_history_printf
</MACRO>
<MACRO>
<NAME>im_updatehist</NAME>
#define im_updatehist vips_image_history_args
</MACRO>
<MACRO>
<NAME>im_history_get</NAME>
#define im_history_get vips_image_get_history
</MACRO>
<MACRO>
<NAME>im_save_string_get</NAME>
#define im_save_string_get vips_value_get_save_string
</MACRO>
<MACRO>
<NAME>im_save_string_set</NAME>
#define im_save_string_set vips_value_set_save_string
</MACRO>
<MACRO>
<NAME>im_save_string_setf</NAME>
#define im_save_string_setf vips_value_set_save_stringf
</MACRO>
<MACRO>
<NAME>im_ref_string_set</NAME>
#define im_ref_string_set vips_value_set_ref_string
</MACRO>
<MACRO>
<NAME>im_ref_string_get</NAME>
#define im_ref_string_get( V ) vips_value_get_ref_string( V, NULL )
</MACRO>
<FUNCTION>
<NAME>im_ref_string_get_length</NAME>
<RETURNS>size_t  </RETURNS>
 const GValue *value 
</FUNCTION>
<MACRO>
<NAME>im_blob_get</NAME>
#define im_blob_get vips_value_get_blob
</MACRO>
<MACRO>
<NAME>im_blob_set</NAME>
#define im_blob_set vips_value_set_blob
</MACRO>
<MACRO>
<NAME>im_meta_set</NAME>
#define im_meta_set( A, B, C ) (vips_image_set( A, B, C ), 0)
</MACRO>
<MACRO>
<NAME>im_meta_remove</NAME>
#define im_meta_remove vips_image_remove
</MACRO>
<MACRO>
<NAME>im_meta_get</NAME>
#define im_meta_get vips_image_get
</MACRO>
<MACRO>
<NAME>im_meta_get_typeof</NAME>
#define im_meta_get_typeof vips_image_get_typeof
</MACRO>
<MACRO>
<NAME>im_meta_set_int</NAME>
#define im_meta_set_int( A, B, C ) (vips_image_set_int( A, B, C ), 0)
</MACRO>
<MACRO>
<NAME>im_meta_get_int</NAME>
#define im_meta_get_int vips_image_get_int
</MACRO>
<MACRO>
<NAME>im_meta_set_double</NAME>
#define im_meta_set_double( A, B, C ) (vips_image_set_double( A, B, C ), 0)
</MACRO>
<MACRO>
<NAME>im_meta_get_double</NAME>
#define im_meta_get_double vips_image_get_double
</MACRO>
<MACRO>
<NAME>im_meta_set_area</NAME>
#define im_meta_set_area( A, B, C, D ) (vips_image_set_area( A, B, C, D ), 0)
</MACRO>
<MACRO>
<NAME>im_meta_get_area</NAME>
#define im_meta_get_area vips_image_get_area
</MACRO>
<MACRO>
<NAME>im_meta_set_string</NAME>
#define im_meta_set_string( A, B, C ) (vips_image_set_string( A, B, C ), 0)
</MACRO>
<MACRO>
<NAME>im_meta_get_string</NAME>
#define im_meta_get_string vips_image_get_string
</MACRO>
<MACRO>
<NAME>im_meta_set_blob</NAME>
#define im_meta_set_blob( A, B, C, D, E ) \
	(vips_image_set_blob( A, B, C, D, E ), 0)
</MACRO>
<MACRO>
<NAME>im_meta_get_blob</NAME>
#define im_meta_get_blob vips_image_get_blob
</MACRO>
<MACRO>
<NAME>im_semaphore_t</NAME>
#define im_semaphore_t VipsSemaphore
</MACRO>
<MACRO>
<NAME>im_semaphore_up</NAME>
#define im_semaphore_up vips_semaphore_up
</MACRO>
<MACRO>
<NAME>im_semaphore_down</NAME>
#define im_semaphore_down vips_semaphore_down
</MACRO>
<MACRO>
<NAME>im_semaphore_upn</NAME>
#define im_semaphore_upn vips_semaphore_upn
</MACRO>
<MACRO>
<NAME>im_semaphore_downn</NAME>
#define im_semaphore_downn vips_semaphore_downn
</MACRO>
<MACRO>
<NAME>im_semaphore_destroy</NAME>
#define im_semaphore_destroy vips_semaphore_destroy
</MACRO>
<MACRO>
<NAME>im_semaphore_init</NAME>
#define im_semaphore_init vips_semaphore_init
</MACRO>
<MACRO>
<NAME>im__open_image_read</NAME>
#define im__open_image_read vips__open_image_read
</MACRO>
<MACRO>
<NAME>im_image_open_input</NAME>
#define im_image_open_input vips_image_open_input
</MACRO>
<MACRO>
<NAME>im_image_open_output</NAME>
#define im_image_open_output vips_image_open_output
</MACRO>
<MACRO>
<NAME>im__read_4byte</NAME>
#define im__read_4byte vips__read_4byte
</MACRO>
<MACRO>
<NAME>im__read_2byte</NAME>
#define im__read_2byte vips__read_2byte
</MACRO>
<MACRO>
<NAME>im__write_4byte</NAME>
#define im__write_4byte vips__write_4byte
</MACRO>
<MACRO>
<NAME>im__write_2byte</NAME>
#define im__write_2byte vips__write_2byte
</MACRO>
<MACRO>
<NAME>im__has_extension_block</NAME>
#define im__has_extension_block vips__has_extension_block
</MACRO>
<MACRO>
<NAME>im__read_extension_block</NAME>
#define im__read_extension_block vips__read_extension_block
</MACRO>
<MACRO>
<NAME>im__write_extension_block</NAME>
#define im__write_extension_block vips__write_extension_block
</MACRO>
<MACRO>
<NAME>im__writehist</NAME>
#define im__writehist vips__writehist
</MACRO>
<MACRO>
<NAME>im__read_header_bytes</NAME>
#define im__read_header_bytes vips__read_header_bytes
</MACRO>
<MACRO>
<NAME>im__write_header_bytes</NAME>
#define im__write_header_bytes vips__write_header_bytes
</MACRO>
<MACRO>
<NAME>VSListMap2Fn</NAME>
#define VSListMap2Fn VipsSListMap2Fn
</MACRO>
<MACRO>
<NAME>VSListMap4Fn</NAME>
#define VSListMap4Fn VipsSListMap4Fn
</MACRO>
<MACRO>
<NAME>VSListFold2Fn</NAME>
#define VSListFold2Fn VipsSListFold2Fn
</MACRO>
<MACRO>
<NAME>im_slist_equal</NAME>
#define im_slist_equal vips_slist_equal
</MACRO>
<MACRO>
<NAME>im_slist_map2</NAME>
#define im_slist_map2 vips_slist_map2
</MACRO>
<MACRO>
<NAME>im_slist_map2_rev</NAME>
#define im_slist_map2_rev vips_slist_map2_rev
</MACRO>
<MACRO>
<NAME>im_slist_map4</NAME>
#define im_slist_map4 vips_slist_map4
</MACRO>
<MACRO>
<NAME>im_slist_fold2</NAME>
#define im_slist_fold2 vips_slist_fold2
</MACRO>
<MACRO>
<NAME>im_slist_filter</NAME>
#define im_slist_filter vips_slist_filter
</MACRO>
<MACRO>
<NAME>im_slist_free_all</NAME>
#define im_slist_free_all vips_slist_free_all
</MACRO>
<MACRO>
<NAME>im_map_equal</NAME>
#define im_map_equal vips_map_equal
</MACRO>
<MACRO>
<NAME>im_hash_table_map</NAME>
#define im_hash_table_map vips_hash_table_map
</MACRO>
<MACRO>
<NAME>im_strncpy</NAME>
#define im_strncpy vips_strncpy
</MACRO>
<MACRO>
<NAME>im_strrstr</NAME>
#define im_strrstr vips_strrstr
</MACRO>
<MACRO>
<NAME>im_ispostfix</NAME>
#define im_ispostfix vips_ispostfix
</MACRO>
<MACRO>
<NAME>im_isprefix</NAME>
#define im_isprefix vips_isprefix
</MACRO>
<MACRO>
<NAME>im_break_token</NAME>
#define im_break_token vips_break_token
</MACRO>
<MACRO>
<NAME>im_vsnprintf</NAME>
#define im_vsnprintf vips_vsnprintf
</MACRO>
<MACRO>
<NAME>im_snprintf</NAME>
#define im_snprintf vips_snprintf
</MACRO>
<MACRO>
<NAME>im_filename_split</NAME>
#define im_filename_split vips_filename_split
</MACRO>
<MACRO>
<NAME>im_skip_dir</NAME>
#define im_skip_dir vips_skip_dir
</MACRO>
<MACRO>
<NAME>im_filename_suffix</NAME>
#define im_filename_suffix vips_filename_suffix
</MACRO>
<MACRO>
<NAME>im_filename_suffix_match</NAME>
#define im_filename_suffix_match vips_filename_suffix_match
</MACRO>
<MACRO>
<NAME>im_getnextoption</NAME>
#define im_getnextoption vips_getnextoption
</MACRO>
<MACRO>
<NAME>im_getsuboption</NAME>
#define im_getsuboption vips_getsuboption
</MACRO>
<MACRO>
<NAME>im_file_length</NAME>
#define im_file_length vips_file_length
</MACRO>
<MACRO>
<NAME>im__write</NAME>
#define im__write vips__write
</MACRO>
<MACRO>
<NAME>im__file_open_read</NAME>
#define im__file_open_read vips__file_open_read
</MACRO>
<MACRO>
<NAME>im__file_open_write</NAME>
#define im__file_open_write vips__file_open_write
</MACRO>
<MACRO>
<NAME>im__file_read</NAME>
#define im__file_read vips__file_read
</MACRO>
<MACRO>
<NAME>im__file_read_name</NAME>
#define im__file_read_name vips__file_read_name
</MACRO>
<MACRO>
<NAME>im__file_write</NAME>
#define im__file_write vips__file_write
</MACRO>
<MACRO>
<NAME>im__get_bytes</NAME>
#define im__get_bytes vips__get_bytes
</MACRO>
<MACRO>
<NAME>im__gvalue_ref_string_new</NAME>
#define im__gvalue_ref_string_new vips__gvalue_ref_string_new
</MACRO>
<MACRO>
<NAME>im__gslist_gvalue_free</NAME>
#define im__gslist_gvalue_free vips__gslist_gvalue_free
</MACRO>
<MACRO>
<NAME>im__gslist_gvalue_copy</NAME>
#define im__gslist_gvalue_copy vips__gslist_gvalue_copy
</MACRO>
<MACRO>
<NAME>im__gslist_gvalue_merge</NAME>
#define im__gslist_gvalue_merge vips__gslist_gvalue_merge
</MACRO>
<MACRO>
<NAME>im__gslist_gvalue_get</NAME>
#define im__gslist_gvalue_get vips__gslist_gvalue_get
</MACRO>
<MACRO>
<NAME>im__seek</NAME>
#define im__seek vips__seek
</MACRO>
<MACRO>
<NAME>im__ftruncate</NAME>
#define im__ftruncate vips__ftruncate
</MACRO>
<MACRO>
<NAME>im_existsf</NAME>
#define im_existsf vips_existsf
</MACRO>
<MACRO>
<NAME>im_popenf</NAME>
#define im_popenf vips_popenf
</MACRO>
<MACRO>
<NAME>im_ispoweroftwo</NAME>
#define im_ispoweroftwo vips_ispoweroftwo
</MACRO>
<MACRO>
<NAME>im_amiMSBfirst</NAME>
#define im_amiMSBfirst vips_amiMSBfirst
</MACRO>
<MACRO>
<NAME>im__temp_name</NAME>
#define im__temp_name vips__temp_name
</MACRO>
<MACRO>
<NAME>IM_VERSION_STRING</NAME>
#define IM_VERSION_STRING VIPS_VERSION_STRING
</MACRO>
<MACRO>
<NAME>IM_MAJOR_VERSION</NAME>
#define IM_MAJOR_VERSION VIPS_MAJOR_VERSION
</MACRO>
<MACRO>
<NAME>IM_MINOR_VERSION</NAME>
#define IM_MINOR_VERSION VIPS_MINOR_VERSION
</MACRO>
<MACRO>
<NAME>IM_MICRO_VERSION</NAME>
#define IM_MICRO_VERSION VIPS_MICRO_VERSION
</MACRO>
<MACRO>
<NAME>IM_EXEEXT</NAME>
#define IM_EXEEXT VIPS_EXEEXT
</MACRO>
<MACRO>
<NAME>IM_SIZEOF_HEADER</NAME>
#define IM_SIZEOF_HEADER VIPS_SIZEOF_HEADER
</MACRO>
<MACRO>
<NAME>im_concurrency_set</NAME>
#define im_concurrency_set vips_concurrency_set
</MACRO>
<MACRO>
<NAME>im_concurrency_get</NAME>
#define im_concurrency_get vips_concurrency_get
</MACRO>
<FUNCTION>
<NAME>im_add</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_subtract</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_multiply</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_divide</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_min</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, double *out 
</FUNCTION>
<FUNCTION>
<NAME>im_minpos</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, int *xpos, int *ypos, double *out 
</FUNCTION>
<FUNCTION>
<NAME>im_max</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, double *out 
</FUNCTION>
<FUNCTION>
<NAME>im_maxpos</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, int *xpos, int *ypos, double *out 
</FUNCTION>
<FUNCTION>
<NAME>im_avg</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, double *out 
</FUNCTION>
<FUNCTION>
<NAME>im_deviate</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, double *out 
</FUNCTION>
<FUNCTION>
<NAME>im_invert</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_lintra</NAME>
<RETURNS>int  </RETURNS>
 double a, VipsImage *in, double b, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_lintra_vec</NAME>
<RETURNS>int  </RETURNS>
 int n, double *a, VipsImage *in, double *b, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_abs</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_sign</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_stats</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 VipsImage *in 
</FUNCTION>
<FUNCTION>
<NAME>im_measure_area</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 VipsImage *im, int left, int top, int width, int height, int h, int v, int *sel, int nsel, const char *name 
</FUNCTION>
<FUNCTION>
<NAME>im_recomb</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, DOUBLEMASK *recomb 
</FUNCTION>
<FUNCTION>
<NAME>im_sintra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_costra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_tantra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_asintra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_acostra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_atantra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_logtra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_log10tra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_exptra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_exp10tra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_floor</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_rint</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_ceil</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_equal</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_notequal</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_less</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_lesseq</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_more</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_moreeq</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_andimage</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_orimage</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_eorimage</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_andimage_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_orimage_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_eorimage_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_andimageconst</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double c 
</FUNCTION>
<FUNCTION>
<NAME>im_orimageconst</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double c 
</FUNCTION>
<FUNCTION>
<NAME>im_eorimageconst</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double c 
</FUNCTION>
<FUNCTION>
<NAME>im_shiftleft_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_shiftleft</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n 
</FUNCTION>
<FUNCTION>
<NAME>im_shiftright_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_shiftright</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n 
</FUNCTION>
<FUNCTION>
<NAME>im_remainder</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_remainder_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_remainderconst</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double c 
</FUNCTION>
<FUNCTION>
<NAME>im_powtra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double e 
</FUNCTION>
<FUNCTION>
<NAME>im_powtra_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *e 
</FUNCTION>
<FUNCTION>
<NAME>im_expntra</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double e 
</FUNCTION>
<FUNCTION>
<NAME>im_expntra_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *e 
</FUNCTION>
<FUNCTION>
<NAME>im_equal_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_notequal_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_less_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_lesseq_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_more_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_moreeq_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int n, double *c 
</FUNCTION>
<FUNCTION>
<NAME>im_equalconst</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double c 
</FUNCTION>
<FUNCTION>
<NAME>im_notequalconst</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double c 
</FUNCTION>
<FUNCTION>
<NAME>im_lessconst</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double c 
</FUNCTION>
<FUNCTION>
<NAME>im_lesseqconst</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double c 
</FUNCTION>
<FUNCTION>
<NAME>im_moreconst</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double c 
</FUNCTION>
<FUNCTION>
<NAME>im_moreeqconst</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double c 
</FUNCTION>
<FUNCTION>
<NAME>im_copy</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_copy_set</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, VipsInterpretation interpretation, float xres, float yres, int xoffset, int yoffset 
</FUNCTION>
<FUNCTION>
<NAME>im_copy_set_meta</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, const char *field, GValue *value 
</FUNCTION>
<FUNCTION>
<NAME>im_copy_morph</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int bands, VipsBandFormat format, VipsCoding coding 
</FUNCTION>
<FUNCTION>
<NAME>im_copy_swap</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_copy_native</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, gboolean is_msb_first 
</FUNCTION>
<FUNCTION>
<NAME>im_embed</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int type, int x, int y, int width, int height 
</FUNCTION>
<FUNCTION>
<NAME>im_fliphor</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_flipver</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_insert</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *main, VipsImage *sub, VipsImage *out, int x, int y 
</FUNCTION>
<FUNCTION>
<NAME>im_insert_noexpand</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *main, VipsImage *sub, VipsImage *out, int x, int y 
</FUNCTION>
<FUNCTION>
<NAME>im_lrjoin</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *left, VipsImage *right, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_tbjoin</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *top, VipsImage *bottom, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_extract_area</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int left, int top, int width, int height 
</FUNCTION>
<FUNCTION>
<NAME>im_extract_band</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int band 
</FUNCTION>
<FUNCTION>
<NAME>im_extract_bands</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int band, int nbands 
</FUNCTION>
<FUNCTION>
<NAME>im_extract_areabands</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int left, int top, int width, int height, int band, int nbands 
</FUNCTION>
<FUNCTION>
<NAME>im_replicate</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int across, int down 
</FUNCTION>
<FUNCTION>
<NAME>im_clip2fmt</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, VipsBandFormat fmt 
</FUNCTION>
<FUNCTION>
<NAME>im_bandjoin</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_gbandjoin</NAME>
<RETURNS>int  </RETURNS>
 VipsImage **in, VipsImage *out, int n 
</FUNCTION>
<FUNCTION>
<NAME>im_black</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, int x, int y, int bands 
</FUNCTION>
<FUNCTION>
<NAME>im_rot90</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_rot180</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_rot270</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_ifthenelse</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *c, VipsImage *a, VipsImage *b, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_blend</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *c, VipsImage *a, VipsImage *b, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_vips2mask</NAME>
<RETURNS>DOUBLEMASK  *</RETURNS>
 VipsImage *in, const char *filename 
</FUNCTION>
<FUNCTION>
<NAME>im_mask2vips</NAME>
<RETURNS>int  </RETURNS>
 DOUBLEMASK *in, VipsImage *out 
</FUNCTION>
<MACRO>
<NAME>vips_class_map_concrete_all</NAME>
#define vips_class_map_concrete_all vips_class_map_all
</MACRO>
<FUNCTION>
<NAME>im_histgr</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int bandno 
</FUNCTION>
<FUNCTION>
<NAME>im_histnD</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int bins 
</FUNCTION>
<FUNCTION>
<NAME>im_hist_indexed</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *index, VipsImage *value, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_identity</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *lut, int bands 
</FUNCTION>
<FUNCTION>
<NAME>im_identity_ushort</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *lut, int bands, int sz 
</FUNCTION>
<FUNCTION>
<NAME>im_invertlut</NAME>
<RETURNS>int  </RETURNS>
 DOUBLEMASK *input, VipsImage *output, int lut_size 
</FUNCTION>
<FUNCTION>
<NAME>im_buildlut</NAME>
<RETURNS>int  </RETURNS>
 DOUBLEMASK *input, VipsImage *output 
</FUNCTION>
<FUNCTION>
<NAME>im_project</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *hout, VipsImage *vout 
</FUNCTION>
<FUNCTION>
<NAME>im_histnorm</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_histcum</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_histeq</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_histspec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *ref, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_ismonotonic</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *lut, int *out 
</FUNCTION>
<FUNCTION>
<NAME>im_histplot</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_maplut</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, VipsImage *lut 
</FUNCTION>
<FUNCTION>
<NAME>im_hist</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int bandno 
</FUNCTION>
<FUNCTION>
<NAME>im_hsp</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *ref, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_gammacorrect</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double exponent 
</FUNCTION>
<FUNCTION>
<NAME>im_mpercent</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, double percent, int *out 
</FUNCTION>
<FUNCTION>
<NAME>im_mpercent_hist</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *hist, double percent, int *out 
</FUNCTION>
<FUNCTION>
<NAME>im_heq</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int bandno 
</FUNCTION>
<FUNCTION>
<NAME>im_lhisteq</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, int xwin, int ywin 
</FUNCTION>
<FUNCTION>
<NAME>im_stdif</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double a, double m0, double b, double s0, int xwin, int ywin 
</FUNCTION>
<FUNCTION>
<NAME>im_tone_build_range</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, int in_max, int out_max, double Lb, double Lw, double Ps, double Pm, double Ph, double S, double M, double H 
</FUNCTION>
<FUNCTION>
<NAME>im_tone_build</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *out, double Lb, double Lw, double Ps, double Pm, double Ph, double S, double M, double H 
</FUNCTION>
<FUNCTION>
<NAME>im_tone_analyse</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, double Ps, double Pm, double Ph, double S, double M, double H 
</FUNCTION>
<FUNCTION>
<NAME>im_tone_map</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out, VipsImage *lut 
</FUNCTION>
<FUNCTION>
<NAME>im_video_v4l1</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, const char *device, int channel, int brightness, int colour, int contrast, int hue, int ngrabs 
</FUNCTION>
<FUNCTION>
<NAME>im_video_test</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, int brightness, int error 
</FUNCTION>
<ENUM>
<NAME>VipsOperationMath</NAME>
typedef enum {
	VIPS_OPERATION_MATH_SIN,
	VIPS_OPERATION_MATH_COS,
	VIPS_OPERATION_MATH_TAN,
	VIPS_OPERATION_MATH_ASIN,
	VIPS_OPERATION_MATH_ACOS,
	VIPS_OPERATION_MATH_ATAN,
	VIPS_OPERATION_MATH_LOG,
	VIPS_OPERATION_MATH_LOG10,
	VIPS_OPERATION_MATH_EXP,
	VIPS_OPERATION_MATH_EXP10,
	VIPS_OPERATION_MATH_LAST
} VipsOperationMath;
</ENUM>
<ENUM>
<NAME>VipsOperationMath2</NAME>
typedef enum {
	VIPS_OPERATION_MATH2_POW,
	VIPS_OPERATION_MATH2_WOP,
	VIPS_OPERATION_MATH2_LAST
} VipsOperationMath2;
</ENUM>
<ENUM>
<NAME>VipsOperationRound</NAME>
typedef enum {
	VIPS_OPERATION_ROUND_NEAREST,
	VIPS_OPERATION_ROUND_CEIL,
	VIPS_OPERATION_ROUND_FLOOR,
	VIPS_OPERATION_ROUND_LAST
} VipsOperationRound;
</ENUM>
<ENUM>
<NAME>VipsOperationRelational</NAME>
typedef enum {
	VIPS_OPERATION_RELATIONAL_EQUAL,
	VIPS_OPERATION_RELATIONAL_NOTEQUAL,
	VIPS_OPERATION_RELATIONAL_LESS,
	VIPS_OPERATION_RELATIONAL_LESSEQ,
	VIPS_OPERATION_RELATIONAL_MORE,
	VIPS_OPERATION_RELATIONAL_MOREEQ,
	VIPS_OPERATION_RELATIONAL_LAST
} VipsOperationRelational;
</ENUM>
<ENUM>
<NAME>VipsOperationBoolean</NAME>
typedef enum {
	VIPS_OPERATION_BOOLEAN_AND,
	VIPS_OPERATION_BOOLEAN_OR,
	VIPS_OPERATION_BOOLEAN_EOR,
	VIPS_OPERATION_BOOLEAN_LSHIFT,
	VIPS_OPERATION_BOOLEAN_RSHIFT,
	VIPS_OPERATION_BOOLEAN_LAST
} VipsOperationBoolean;
</ENUM>
<FUNCTION>
<NAME>vips_add</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *left, VipsImage *right, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_arithmetic_add</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *left, VipsImage *right, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_subtract</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in1, VipsImage *in2, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_multiply</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *left, VipsImage *right, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_divide</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *left, VipsImage *right, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_avg</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, double *out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_deviate</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, double *out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_min</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, double *out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_max</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, double *out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_invert</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_linear</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, double *a, double *b, int n, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_linear1</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, double a, double b, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_math</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, VipsOperationMath math, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_abs</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_sign</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_stats</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_measure</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, int h, int v, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_recomb</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, VipsImage *m, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_round</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, VipsOperationRound round, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_relational</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *left, VipsImage *right, VipsImage **out, VipsOperationRelational relational, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_relational_const</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, VipsOperationRelational relational, double *c, int n, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_relational_const1</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, VipsOperationRelational relational, double c, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_remainder</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *left, VipsImage *right, VipsImage **out, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_remainder_const</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, double *c, int n, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_remainder_const1</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, double c, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_boolean</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *left, VipsImage *right, VipsImage **out, VipsOperationBoolean boolean, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_boolean_const</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, VipsOperationBoolean boolean, double *c, int n, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_math2</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *left, VipsImage *right, VipsImage **out, VipsOperationMath2 math2, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_math2_const</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, VipsOperationMath2 math2, double *c, int n, ... 
</FUNCTION>
<FUNCTION>
<NAME>vips_math2_const1</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage **out, VipsOperationMath2 math2, double c, ... 
</FUNCTION>
<FUNCTION>
<NAME>im_maxpos_avg</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, double *xpos, double *ypos, double *out 
</FUNCTION>
<FUNCTION>
<NAME>im_maxpos_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, int *xpos, int *ypos, double *maxima, int n 
</FUNCTION>
<FUNCTION>
<NAME>im_minpos_vec</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, int *xpos, int *ypos, double *minima, int n 
</FUNCTION>
<FUNCTION>
<NAME>im_bandmean</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *in, VipsImage *out 
</FUNCTION>
<FUNCTION>
<NAME>im_linreg</NAME>
<RETURNS>int  </RETURNS>
 VipsImage **ins, VipsImage *out, double *xs 
</FUNCTION>
<FUNCTION>
<NAME>im_point</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, VipsInterpolate *interpolate, double x, double y, int band, double *out 
</FUNCTION>
<FUNCTION>
<NAME>im_point_bilinear</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *im, double x, double y, int band, double *out 
</FUNCTION>
<FUNCTION>
<NAME>im_cross_phase</NAME>
<RETURNS>int  </RETURNS>
 VipsImage *a, VipsImage *b, VipsImage *out 
</FUNCTION>
