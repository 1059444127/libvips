- make VipsThread opaque ... have a separate VipsThreadState struct holding
  stuff and only expose that

- add progress feedback ... main thread should wake on every tile? or every
  buffer write? or every second?

- try with im_render(), ouch, that will be painful

- switch other file sinks over, maybe have a shim layer?

- switch im_iterate() over?

- do we have other uses of threadgroup?

- nip2 image display does not work with threading disabled

- try a distributed worker model for image generation

  at the moment threadpools have an idle list and a manager ... in fact, what
  will generally happen during a run is;

  	* idle list is empty 99% of the time ...
	* a worker finishes, locks the idle list, adds itself, signals 
	  on the 'idle' semaphone that someone is waiting, and then waits
	  itself in 'go'
	* manager wakes up, locks the idle list, gets the worker, assigns
	  a task, signals on 'go' and sleeps again on 'idle'
	* worker wakes up and starts processing again on the new task

  we can make this a lot simpler if we allow workers to assign themselves
  tasks, something like

  	* worker finishes a tile
	* worker locks the assign-task mutex, runs a function to set new
	  parameters, and unlocks
	* the task can be 'generate a tile' or 'job done, you can quit', or
	  'there has been an error, abort' or anything really
	* worker starts on the next thing

  then we need some simple stuff so that the background write thread knows
  when a buffer is complete: the task-allocate function needs to cooperate
  with the background writer, not too hard

  so threadpool needs to have a set of threads and a mutex and ... erm that's
  it, perhaps there's some common stuff we could put in there, quit? error
  handling?

  make a new thing, junk threadgroup

  VipsThreadPool?

- doing im_create_fmask() and friends

- try writing docs for vipsthumbnail with gtkdoc? then try header etc.

  we need to have a separate docs package for the tools/ dir

- rename header, edvips as vipsheader, vipsedit

  maybe have back compat links?

- should im_rwcheck() copy to disc?

  maybe im_rwcheck_disc() copies to im->filename and maps that

  rather awkward to do atm with the way check.c is structured

- what does G_UNLIKELY() do? can we use it?

- rename vipsCC in SWIG as pyvips?

- look into G_GNUC_DEPRECATED for back compat in vips8

- use

	http://library.gnome.org/devel/glib/stable/glib-Byte-Order-Macros.html

  for swapping ... they are asm macros so we should see a speedup

- can we use conv_sep to speed up the memuse benchmarks?

- move im_shrink & friends to resample?

  match_linear, match_linear_search?

  what about im_stretch3.c, im_resize_linear

- im_render should use a hash for tile lookup ... or+shift x/y together

  load wtc.jpg, rotate 42 degrees, zoom in and out quickly for a while, quit

  tiles are leaked :(

  does not leak if you wait for repaint to finish before zooming/unzooming

  problem with waiting for paint to finish in render_kill?

- check mosaic1, global_balance, similarity etc. use of im__affine
  
  how can we move them to im_affinei ?

- radiance read/write needs docs

  maybe have an im_format(3) page with all the built-in formats?

  hard until we document vips_object :(

- same for matio?

- doc strings would be nice, read the SWIG notes on this

- bilateral filtering, see:

	http://en.wikipedia.org/wiki/Bilateral_filter
	http://www.shellandslate.com/fastmedian.html

  also a mail from Martin Breidt has links to several fast free C
  implementations

- try making vips_add(), an operator as a class

- need to write interpolate docs ... manpages and tutorial

  difficult without docs for vips_object

- need a section for vipsobject in the tutorial

  also a manpage?

  not really stable yet :( don't document

- how to expose things like yafrsmooth's "sharpening" parameter to
  C++/Python?

  can we write a find-by-nickname function? eg.

  	GType vips_get_type (const char *base, const char *nickname)

  then 

  	vips_get_type ("VipsInterpolator", "bicubic")

  would get us the GType for VipsInterpolatorBicubic

- we shouldn't need to call im_invalidate() in gtkdisp4 :( how can we fix
  this?

  will im_invalidate() trash the render cache too?

- we should wrap the format API, also im_render*(), see gtkdisp.cc for sample
  code

- have a base VObject class and put the ref stuff in there ... share between
  VMask, VDisplay, VImage

- need an im_init_world() for C++ which does cmd-line args too, so C++ progs
  can get --vips-progress and stuff automatically

- more cleanups to the handling of vips format images, esp. we have vips write
  spread across many files atm

- could remove a lot of crappy old API

- try

	libsrc/convolution$ grep -l offsets *.c

  could we do the don't calc offsets thing unless bpl; changes thing in more
  places?

- unsharp should work on GREY16? should be easy to add GREY16->LABS

  no, labs is signed short, ranges are all differrent, and the scaling will be
  wrong anyway

  correct: import with ICC to labs, then process, then export to RGB, take
  green?

  yuk, can we add a 16bit path to vips's lab <--> rgb converter?

  use TIFF RGB16 as the 16bit RGB target

  im_XYZ2disp() would be easy to 16bit ... just need the 1,500 element table
  table->t_Yr2r[i] expanded
  
  im_disp2XYZ() uses im_col_rgb2XYZ() in a loop ... again, need
  the 1,500 element table table->t_r2Yr[i] expanded

  usually these three tables (t_r2Yr, t_g2Yg, t_b2Yb) will be identical, can
  we common them up? same for t_Yr2r etc.

  how big should the table be for 16 bits? 256 times larger? too big!

  we really just need a LUT for pow() with the right exponent, eg. 2.4 for
  sRGBs, and one for 1/2.4 ... see what calcul_tables does:

  	table->t_r2Yr[i] = yo + a * pow( i * table->ristep / f + c, ga );

  see



  

- test maxpos_avg, quite a few changes

- HAVE_HYPOT could define a hypot() macro?

- im_exr2vips can now use c++ api

  see TODO notes in openexr read (though they all need more openexr C API)

  consider openexr write

- python startup fails with plugins in vipslib:

	Fatal Python error: can't initialise module vips
	plugin: unable to open plugin "/home/john/vips/lib/resample.plg"
	plugin: /home/john/vips/lib/resample.plg: undefined symbol: im_start_one

  do we need to build plugins with -rpath etc. and more libs?

  or do we need to make sure our python modules export all their im_ symbols?

  check:

  	http://www.swig.org/Doc1.3/SWIGDocumentation.html#Python_nn8
	http://docs.python.org/dist/dist.html

- write our own python extension to call a vips operation by name

	result = vips_call ("name", args)

  then call that from VImage_method

- do we really need VImage_method? Can't we write

	__getattr__ (self, name) = lambda (obj_to_call, arguments):

  or something like that?

- TIFF load/save should use meta system for unknown tags

- balance should use new meta stuff

- magick2vips should spot ICC profiles and attach them as meta

- also png2vips?

- magick should set some header field for n_frames and frame_height? see also
  analyze

- im_csv2vips() could use "-" for filename to mean stdin

  but then we'd have to read to a malloced buffer of some sort rather than an
  image, since we might need to grow it during the read, since we couldn't
  then seek

- add erode/dilate 3x3 special case using a 512-bit LUT

  ... nope, actually slower :-( we end up doing an inner loop like

  	for( i = 0; i < 9; i++ )
		bits |= (p[o[i]] != 0) << i;

  which is horrible. Maybe if we had a one band true 1 bit image it'd be
  quicker since we could get bits out in parallel and wouldn't have to worry
  about converting non-zero to 1

  could have a Coding type for bitpack? eg. relational produces a bitpack
  image by default, boolean & morph can work on bitpack etc

  maybe something for vips8 ... we could have a flag on operations for the
  coding types they can accept, and if they are passed other type, they are
  automatically converted

- non-linear sharpen: replace each pixel by the lightest or darkest neighbour
  depending on which is closer in value

- can wrap other inplace funcs which use ink now we have vector_to_ink() in
  inplace_dispatch.c

  see also comments in nip2 TODO ... we could auto-wrap in vips_call.c

  cleaner!

- on win32, should not write matrix files in binary mode, we want CR/LF chars
  so we can load into excel etc easily

  how odd, we're doing

	if( !(fp = fopen( name, "w" )) ) {

  shouldn't be binary ... hmm
